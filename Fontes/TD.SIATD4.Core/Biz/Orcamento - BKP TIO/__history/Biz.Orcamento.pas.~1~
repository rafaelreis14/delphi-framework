unit Biz.Orcamento;

interface

uses
    Classes, System.SysUtils, Dialogs, Lib.Base, Lib.Parametro, Lib.Enumeradores, System.Math, DateUtils,
    Lib.Persistable, Lib.Biblioteca,  Biz.Cliente, Biz.Vendedor, lib.ResultFilter, lib.Lista, Biz.Produto, Biz.Filial,
    Lib.MaxLenght, StrUtils, RComboBox,
    Biz.CreditoCliente, ComCtrls;

type
    TTipoFrete = (toEmitente = 1, toDestinatario = 2, toSemFrete = 9);

    TStatusConferencia = (Aguardando, Conferindo, Conferido);

    TTipoDeRateio = (trDespesas, trDesconto, trSeguro, trFrete);

    TOrcamento = class(TBase)
    private
{$REGION 'Variáveis de propriedade'}
        FPesoBruto: double;
        FValorFrete: double;
        FCodigoOperadorPDV: string;
        FValorDespesa: double;
        FTipoOrcamento: string;
        FDataEmissaoDocumento: string;
        FValorIpi: double;
        FValorBruto: double;
        FFilial: string;
        FBairro: string;
        FHora: string;
        FTipoCliente: string;
        FValorDesconto: double;
        FPercDesconto: double;
        FNomeVendedor: string;
        FVendaComTEF: string;
        FValorPagoCartaoCredito: double;
        FCodigoPDV: string;
        FRecnoDelete: integer;
        FCodigoOrcamentoOrigem: string;
        FValorIcms: double;
        FCep: string;
        FValorSeguro: double;
        FNumero: string;
        FCodigoTransportadora: string;
        FCodigoFormaPagto: string;
        FTipoVolume: string;
        FMunicipio: string;
        FValorTotal: double;
        FDataEmissao: string;
        FRecno: integer;
        FPesoLiquido: double;
        FValorPagoFinan: double;
        FValorPagoCheque: double;
        FTipoDaVenda: string;
        FVolume: double;
        FValorPagoDinheiro: double;
        FDataLimiteValidade: string;
        FCodigoCliente: string;
        FTipoFrete: string;
        FSenhaAutorizador: string;
        FValorLiquido: double;
        FLojaTransportadora: string;
        FDataDigitacao: string;
        FDelete: string;
        FObservacao2: string;
        FCodigoVendedor: string;
        FUsuario: string;
        FSerieDocumento: string;
        FEndereco: string;
        FObservacao1: string;
        FLojaCliente: string;
        FEstado: string;
        FNumeroDocumento: string;
        FOrcamentoPagamento: TLista<TOrcamentoPagamento>;
        FCliente: TCliente;
        FVendedor: TVendedor;
        FOrcamentoItens: TLista<TOrcamentoItens>;
        FOrcamentosFilhos: TLista<TOrcamento>;
        FCopiaCompleta: boolean;
        FValorSubstituicao: double;
        FTipoNotaFiscalMicrossiga: string;
        FUltimoItemAlterado: TOrcamentoItens;
        FNumeroIdentificacaoTef: string;
        FCodigoEstacaoMS: String;
        FValorMercadoria: double;
        FOperacaoVenda: string;
        FControleEntrega: string;
        FOrcamentoGeradoPeloSiatd: string;
        FNomeCliente: string;
        FStatusEnvioEcommerce: string;
        FNumeroPedidoEcommerce: string;
        FStatusPedidoEcommerce: string;
        FValorFreteTodimoTransporte: double;
        FTipoDesconto: string;
        FStatusLiberacaoEntregaFutura: string;
        FValorPagoCartaoDebito: double;
        FUsuarioQueBloqueouOrcamento: string;
        FMoeda: double;
        FPlacaTransportadora: string;
        FCodigoVeiculoTransportadora: string;
        FUFPlancaTransportadora: string;
        FBaseICMSRestido: double;
        FTipo: string;
        FValorPagoConven: double;
        FVersaoSistema: string;
        FValorPagoDuplicata: double;
        FFilial_: TFilial;
        FOrcamentoConferencia: TOrcamento;
        FStatusConferencia: TStatusConferencia;
        FTipoEntregaPadrao: TTipoEntrega;
        FTipoVenda: TTipoVenda;
        FValorEntrada: double;
        FValorPromocao: double;
        FTabelaComissao: TTabelaComissao;
        FTabelaComissaoQuantidadeParcelas: integer;
        FCreditosCliente: TLista<TCreditoCliente>;
        FValorAcrescimosTotalNegociado: double;
        FValorDescontoTotalNegociado: double;
    FCPFCNPJImpressao: string;
{$ENDREGION}
{$REGION 'Metodos Get Set'}
        procedure SetBairro(const Value: string);
        procedure SetCep(const Value: string);
        procedure SetCodigoCliente(const Value: string);
        procedure SetCodigoFormaPagto(const Value: string);
        procedure SetCodigoOperadorPDV(const Value: string);
        procedure SetCodigoOrcamentoOrigem(const Value: string);
        procedure SetCodigoPDV(const Value: string);
        procedure SetCodigoTransportadora(const Value: string);
        procedure SetCodigoVendedor(const Value: string);
        procedure SetDataDigitacao(const Value: string);
        procedure SetDataEmissao(const Value: string);
        procedure SetDataEmissaoDocumento(const Value: string);
        procedure SetDataLimiteValidade(const Value: string);
        procedure SetDelete(const Value: string);
        procedure SetEndereco(const Value: string);
        procedure SetEstado(const Value: string);
        procedure SetFilial(const Value: string);
        procedure SetHora(const Value: string);
        procedure SetLojaCliente(const Value: string);
        procedure SetLojaTransportadora(const Value: string);
        procedure SetMunicipio(const Value: string);
        procedure SetNomeVendedor(const Value: string);
        procedure SetNumero(const Value: string);
        procedure SetNumeroDocumento(const Value: string);
        procedure SetObservacao1(const Value: string);
        procedure SetObservacao2(const Value: string);
        procedure SetPercDesconto(const Value: double);
        procedure SetPesoBruto(const Value: double);
        procedure SetPesoLiquido(const Value: double);
        procedure SetRecno(const Value: integer);
        procedure SetRecnoDelete(const Value: integer);
        procedure SetSenhaAutorizador(const Value: string);
        procedure SetSerieDocumento(const Value: string);
        procedure SetTipoCliente(const Value: string);
        procedure SetTipoDaVenda(const Value: string);
        procedure SetTipoFrete(const Value: string);
        procedure SetTipoOrcamento(const Value: string);
        procedure SetTipoVolume(const Value: string);
        procedure SetUsuario(const Value: string);
        procedure SetValorBruto(const Value: double);
        procedure SetValorDesconto(const Value: double);
        procedure SetValorDespesa(const Value: double);
        procedure SetValorFrete(const Value: double);
        procedure SetValorIcms(const Value: double);
        procedure SetValorIpi(const Value: double);
        procedure SetValorLiquido(const Value: double);
        procedure SetValorPagoCartaoCredito(const Value: double);
        procedure SetValorPagoCheque(const Value: double);
        procedure SetValorPagoDinheiro(const Value: double);
        procedure SetValorPagoFinan(const Value: double);
        procedure SetValorSeguro(const Value: double);
        procedure SetValorTotal(const Value: double);
        procedure SetVendaComTEF(const Value: string);
        procedure SetVolume(const Value: double);
        procedure SetCliente(const Value: TCliente);
        procedure SetVendedor(const Value: TVendedor);
        function GetValorBruto: double;
        function GetValorDesconto: double;
        function GetValorDespesa: double;
        function GetValorFrete: double;
        function GetValorIcms: double;
        function GetValorIpi: double;
        function GetValorLiquido: double;
        function GetValorSeguro: double;
        function GetValorTotal: double;
        procedure SetOrcamentosFilhos(const Value: TLista<TOrcamento>);
        procedure SetCopiaCompleta(const Value: boolean);
        procedure SetValorSubstituicao(const Value: double);
        function GetValorSubstituicao: double;
        procedure SetTipoNotaFiscalMicrossiga(const Value: string);
        procedure SetUltimoItemAlterado(const Value: TOrcamentoItens);
        procedure SetNumeroIdentificacaoTef(const Value: string);
        procedure SetCodigoEstacaoMS(const Value: String);
        function GetOrcamentoComPrecoNegociado: boolean;
        function GetOrcamentoComTabela: boolean;
        function GetOrcamentoComProdutoSelf: boolean;
        function GetCupomOuNotaFiscal: string;
        procedure SetValorMercadoria(const Value: double);
        function GetValorMercadoria: double;
        procedure SetOperacaoVenda(const Value: string);
        procedure SetControleEntrega(const Value: string);
        procedure SetOrcamentoGeradoPeloSiatd(const Value: string);
        procedure SetNomeCliente(const Value: string);
        procedure SetNumeroPedidoEcommerce(const Value: string);
        procedure SetStatusEnvioEcommerce(const Value: string);
        procedure SetStatusPedidoEcommerce(const Value: string);
        procedure SetValorFreteTodimoTransporte(const Value: double);
        procedure SetTipoDesconto(const Value: string);
        function GetTipoDesconto: string;
        procedure SetStatusLiberacaoEntregaFutura(const Value: string);
        procedure SetValorPagoCartaoDebito(const Value: double);
        procedure SetUsuarioQueBloqueouOrcamento(const Value: string);
        procedure SetMoeda(const Value: double);
        procedure SetCodigoVeiculoTransportadora(const Value: string);
        procedure SetPlacaTransportadora(const Value: string);
        procedure SetUFPlancaTransportadora(const Value: string);
        procedure SetBaseICMSRestido(const Value: double);
        procedure SetTipo(const Value: string);
        procedure SetValorPagoConven(const Value: double);
        procedure SetVersaoSistema(const Value: string);
        function GetVersaoSistema: string;
        procedure SetValorPagoDuplicata(const Value: double);
        procedure SetFilial_(const Value: TFilial);
        function GetStatusConferencia: TStatusConferencia;
        function GetTipoEntregaPadrao: TTipoEntrega;
        function GetTipoVenda: TTipoVenda;
        procedure SetTipoVenda(const Value: TTipoVenda);
        procedure SetValorEntrada(const Value: double);
        procedure SetValorPromocao(const Value: double);
        procedure SetTabelaComissao(const Value: TTabelaComissao);
        procedure SetTabelaComissaoQuantidadeParcelas(const Value: integer);
        procedure SetCreditosCliente(const Value: TLista<TCreditoCliente>);

        function GerarParcelasOutros(quantidadeParcelas_GP, dias_GP, intervalo_GP, ultimaSequenciaCartao_GP: integer;
            tipoGeracaoParcela_GP: TTipoGeracaoParcela; formaPagamento_GP: TFormaPagamento;
            primeiraDataVcto_GP, administradoraDescricao_GP, tipoCheque_GP, agenciaBanco_GP, conta_GP, rg_GP, cgc_GP, telefone_GP, observacao_GP,
            numeroDocumento_GP, nomeCliente_GP: String; valorParcela_GP, valorTotalRestante_GP: double): boolean;
        function GerarParcelasTDC(primeiraDataVcto_GP, administradoraDescricao_GP: string; formaPagamento_GP: TFormaPagamento): boolean;
        procedure SetValorAcrescimosTotalNegociado(const Value: double);
        procedure SetValorDescontoTotalNegociado(const Value: double);

{$ENDREGION}
        procedure PreencherTreeView(treeView: TTreeView);
        procedure AddTreeView(pai, filho: String; treeView: TTreeView);
        function AddTreeViewDeletar(item: TOrcamentoItens; treeView: TTreeView): boolean;
        function PreencheTreeViewDeletar(item: TOrcamentoItens; treeView: TTreeView): boolean;

        procedure ObterArvoreProdutosCrossSelling(item: TOrcamentoItens; treeView: TTreeView);
    procedure SetCPFCNPJImpressao(const Value: string);

    public
{$REGION 'Orçamento'}
{$REGION 'propriedades Orcamento'}

        [TPersistable(fgPersistable, 'Z3_FILIAL')]
        property Filial: string read FFilial write SetFilial;

        property Filial_: TFilial read FFilial_ write SetFilial_;

        [TPersistable(fgPersistable, 'Z3_NUM')]
        property Numero: string read FNumero write SetNumero;

        [TPersistable(fgPersistable, 'Z3_VEND')]
        property CodigoVendedor: string read FCodigoVendedor write SetCodigoVendedor;

        [TPersistable(fgPersistable, 'Z3_NOMVDO')]
        property NomeVendedor: string read FNomeVendedor write SetNomeVendedor;

        property Vendedor: TVendedor read FVendedor write SetVendedor;

        [TPersistable(fgPersistable, 'Z3_CLIENTE')]
        property CodigoCliente: string read FCodigoCliente write SetCodigoCliente;

        [TPersistable(fgPersistable, 'Z3_TDNOMCL')]
        [TMaxLenght(30)]
        property NomeCliente: string read FNomeCliente write SetNomeCliente;

        /// <summary>
        /// Campo que guarda o sequencial do cliente. Z3_loja foi usado para
        /// este propósito
        /// </summary>
        [TPersistable(fgPersistable, 'Z3_LOJA')]
        property SequencialCliente: string read FLojaCliente write SetLojaCliente;

        property Cliente: TCliente read FCliente write SetCliente;

        [TPersistable(fgPersistable, 'Z3_CGCCLI')]
        property CPFCNPJImpressao: string read FCPFCNPJImpressao write SetCPFCNPJImpressao;

        [TPersistable(fgPersistable, 'Z3_ORCLIB')]
        property TipoOrcamento: string read FTipoOrcamento write SetTipoOrcamento;

        [TPersistable(fgPersistable, 'Z3_EMISSAO')]
        property DataEmissao: string read FDataEmissao write SetDataEmissao;

        [TPersistable(fgPersistable, 'Z3_HORA')]
        property Hora: string read FHora write SetHora;

        [TPersistable(fgPersistable, 'Z3_TIPOCLI')]
        property TipoCliente: string read FTipoCliente write SetTipoCliente;

{$REGION 'Valores Totalizados'}
        /// <summary>
        /// Valor bruto do orçamento sem desconto
        /// </summary>
        [TPersistable(fgPersistable, 'Z3_VLRTOT')]
        property ValorTotal: double read GetValorTotal write SetValorTotal;

        /// <summary>
        /// Total dos descontos consedidos no orçamento, ou seja, é o valor desconto digitado
        /// duranta a negociação da forma de pagamento, ou desconto geral.
        /// </summary>
        [TPersistable(fgPersistable, 'Z3_DESCONT')]
        property ValorDesconto: double read GetValorDesconto write SetValorDesconto;

        /// <summary>
        /// Valor pago pelo cliente
        /// </summary>
        [TPersistable(fgPersistable, 'Z3_VLRLIQ')]
        property ValorLiquido: double read GetValorLiquido write SetValorLiquido;

        /// <summary>
        /// Valor bruto do orcamento sem desconto
        /// </summary>
        [TPersistable(fgPersistable, 'Z3_VALBRUT')]
        property ValorBruto: double read GetValorBruto write SetValorBruto;

        /// <summary>
        /// Soma dos valors dos produtos
        /// </summary>
        [TPersistable(fgPersistable, 'Z3_VALMERC')]
        property ValorMercadoria: double read GetValorMercadoria write SetValorMercadoria;

        [TPersistable(fgPersistable, 'Z3_VALICM')]
        property ValorIcms: double read GetValorIcms write SetValorIcms;

        [TPersistable(fgPersistable, 'Z3_ICMSRET')]
        property ValorSubstituicao: double read GetValorSubstituicao write SetValorSubstituicao;

        [TPersistable(fgPersistable, 'Z3_VALIPI')]
        property ValorIpi: double read GetValorIpi write SetValorIpi;

        [TPersistable(fgPersistable, 'Z3_FRETE')]
        property ValorFrete: double read GetValorFrete write SetValorFrete;

        [TPersistable(fgPersistable, 'Z3_SEGURO')]
        property ValorSeguro: double read GetValorSeguro write SetValorSeguro;

        /// <summary>
        /// Total das despesas consedidos no orçamento, ou seja, é o valor de despesa digitado
        /// duranta a negociação da forma de pagamento, ou despesa geral.
        /// </summary>
        [TPersistable(fgPersistable, 'Z3_DESPESA')]
        property ValorDespesa: double read GetValorDespesa write SetValorDespesa;

        /// <summary>
        /// Propriedade que indica ao usuario qual o valor dos produto que esta em promoção
        /// </summary>
        property ValorPromocao: double read FValorPromocao write SetValorPromocao;

        /// <summary>
        /// Esta propriedade é diferente a propriedade FValorDesconto.
        /// É o valor desconto geral (FValorDesconto) mais os descontos negociados
        /// diretamento no produto.
        /// </summary>
        property ValorDescontoTotalNegociado: double read FValorDescontoTotalNegociado write SetValorDescontoTotalNegociado;

        /// <summary>
        /// Esta propriedade é diferente a propriedade FValorDespesa.
        /// É o valor de despesa geral (FValorDespesa) mais os acréscimos negociados
        /// diretamento no produto.
        /// </summary>
        property ValorAcrescimosTotalNegociado: double read FValorAcrescimosTotalNegociado write SetValorAcrescimosTotalNegociado;

{$ENDREGION}
        /// <summary>
        /// Z3_DESCONT > 0 then '1' else ''
        /// </summary>
        [TPersistable(fgPersistable, 'Z3_TIPODES')]
        property TipoDesconto: string read GetTipoDesconto write SetTipoDesconto;

        /// <summary>
        /// Validade do orçamento
        /// </summary>
        [TPersistable(fgPersistable, 'Z3_DTLIM')]
        property DataLimiteValidade: string read FDataLimiteValidade write SetDataLimiteValidade;

        [TPersistable(fgPersistable, 'Z3_DOCTD')]
        property NumeroDocumento: string read FNumeroDocumento write SetNumeroDocumento;

        [TPersistable(fgPersistable, 'Z3_SERTD')]
        property SerieDocumento: string read FSerieDocumento write SetSerieDocumento;

        [TPersistable(fgPersistable, 'Z3_PDV')]
        property CodigoPDV: string read FCodigoPDV write SetCodigoPDV;

        [TPersistable(fgPersistable, 'Z3_OPERADO')]
        property CodigoOperadorPDV: string read FCodigoOperadorPDV write SetCodigoOperadorPDV;

        [TPersistable(fgPersistable, 'Z3_EMISNF')]
        property DataEmissaoDocumento: string read FDataEmissaoDocumento write SetDataEmissaoDocumento;

        [TPersistable(fgPersistable, 'Z3_DESCNF')]
        property PercDesconto: double read FPercDesconto write SetPercDesconto;

        [TPersistable(fgPersistable, 'Z3_DINHEIR')]
        property ValorPagoDinheiro: double read FValorPagoDinheiro write SetValorPagoDinheiro;

        [TPersistable(fgPersistable, 'Z3_CHEQUES')]
        property ValorPagoCheque: double read FValorPagoCheque write SetValorPagoCheque;

        [TPersistable(fgPersistable, 'Z3_CARTAO')]
        property ValorPagoCartaoCredito: double read FValorPagoCartaoCredito write SetValorPagoCartaoCredito;

        [TPersistable(fgPersistable, 'Z3_VLRDEBI')]
        property ValorPagoCartaoDebito: double read FValorPagoCartaoDebito write SetValorPagoCartaoDebito;

        [TPersistable(fgPersistable, 'Z3_CONVENI')]
        property ValorPagoConven: double read FValorPagoConven write SetValorPagoConven;

        [TPersistable(fgPersistable, 'Z3_FINANC')]
        property ValorPagoFinan: double read FValorPagoFinan write SetValorPagoFinan;

        [TPersistable(fgPersistable, 'Z3_OUTROS')]
        property ValorPagoDuplicata: double read FValorPagoDuplicata write SetValorPagoDuplicata;

        /// <summary>
        /// Para NFE = '', outros= 'FI'
        /// </summary>
        [TPersistable(fgPersistable, 'Z3_FORMPG')]
        property CodigoFormaPagto: string read FCodigoFormaPagto write SetCodigoFormaPagto;

        [TPersistable(fgPersistable, 'Z3_VENDTEF')]
        property VendaComTEF: string read FVendaComTEF write SetVendaComTEF;

        /// <summary>
        /// Venda Futura, 4-FAT e 6-FUT =  orcamento + 'ORC' + Filial +  Data Emissao
        /// data Quem preenche é o microsiga
        /// </summary>
        [TPersistable(fgPersistable, 'Z3_AUTSENH')]
        property SenhaAutorizador: string read FSenhaAutorizador write SetSenhaAutorizador;

        [TPersistable(fgPersistable, 'Z3_OBS1')]
        property Observacao1: string read FObservacao1 write SetObservacao1;

        [TPersistable(fgPersistable, 'Z3_OBS2')]
        property Observacao2: string read FObservacao2 write SetObservacao2;

        /// <summary>
        /// Data Inclusão do orçamento
        /// </summary>
        [TPersistable(fgPersistable, 'Z3_DTCAD')]
        property DataDigitacao: string read FDataDigitacao write SetDataDigitacao;

        [TPersistable(fgPersistable, 'Z3_CODTRAN')]
        property CodigoTransportadora: string read FCodigoTransportadora write SetCodigoTransportadora;

        [TPersistable(fgPersistable, 'Z3_LOJTRAN')]
        property LojaTransportadora: string read FLojaTransportadora write SetLojaTransportadora;

        /// <summary>
        /// 1-Emitente 2-Destinatário 9-Sem Frete
        /// </summary>
        [TPersistable(fgPersistable, 'Z3_TIPFRET')]
        property TipoFrete: string read FTipoFrete write SetTipoFrete;

        [TPersistable(fgPersistable, 'Z3_ENDENT')]
        [TMaxLenght(60)]
        property Endereco: string read FEndereco write SetEndereco;

        [TPersistable(fgPersistable, 'Z3_BAIRROE')]
        property Bairro: string read FBairro write SetBairro;

        [TPersistable(fgPersistable, 'Z3_CEPE')]
        property Cep: string read FCep write SetCep;

        [TPersistable(fgPersistable, 'Z3_MUNE')]
        property Municipio: string read FMunicipio write SetMunicipio;

        [TPersistable(fgPersistable, 'Z3_ESTE')]
        property Estado: string read FEstado write SetEstado;

        [TPersistable(fgPersistable, 'Z3_PLIQUI')]
        property PesoLiquido: double read FPesoLiquido write SetPesoLiquido;

        [TPersistable(fgPersistable, 'Z3_PBRUTO')]
        property PesoBruto: double read FPesoBruto write SetPesoBruto;

        [TPersistable(fgPersistable, 'Z3_VOLUME')]
        property Volume: double read FVolume write SetVolume;

        [TPersistable(fgPersistable, 'Z3_ESPECIE')]
        property TipoVolume: string read FTipoVolume write SetTipoVolume;

        /// <summary>
        /// Nome usuario ultima alteração
        /// </summary>
        [TPersistable(fgPersistable, 'Z3_USERID')]
        property Usuario: string read FUsuario write SetUsuario;

        /// <summary>
        /// Filial + Orçamento de Origem
        /// </summary>
        [TPersistable(fgPersistable, 'Z3_DOCORIG')]
        property NumeroOrcamentoOrigem: string read FCodigoOrcamentoOrigem write SetCodigoOrcamentoOrigem;

        /// <summary>
        /// Nos orcamentos filhos, se for 9-PSE = 'PE' else 'OD'
        /// </summary>
        [TPersistable(fgPersistable, 'Z3_TIPOVEN')]
        property TipoDaVenda: string read FTipoDaVenda write SetTipoDaVenda;

        property TipoVenda: TTipoVenda read GetTipoVenda write SetTipoVenda;

        /// <summary>
        /// venda Rapida Mae = 'R'
        /// venda futura Mae = 'F',
        /// 8-EOK = 'F',
        /// 6-FUT = 'O'
        /// </summary>
        [TPersistable(fgPersistable, 'Z3_OPERACA')]
        property OperacaoVenda: string read FOperacaoVenda write SetOperacaoVenda;

        /// <summary>
        /// É preenchido com 'S' no orcamento mae, quando tem filhos 6-FUT, 9-ENT ou 9-ENL
        /// </summary>
        [TPersistable(fgPersistable, 'Z3_ENTREG')]
        property ControleEntrega: string read FControleEntrega write SetControleEntrega;

        [TPersistable(fgPersistable, 'Z3_SIATD')]
        property OrcamentoGeradoPeloSiatd: string read FOrcamentoGeradoPeloSiatd write SetOrcamentoGeradoPeloSiatd;

        [TPersistable(fgPersistable, 'Z3_TDNUME')]
        property NumeroPedidoEcommerce: string read FNumeroPedidoEcommerce write SetNumeroPedidoEcommerce;

        [TPersistable(fgPersistable, 'Z3_TDSTPED')]
        property StatusPedidoEcommerce: string read FStatusPedidoEcommerce write SetStatusPedidoEcommerce;

        [TPersistable(fgPersistable, 'Z3_TDFLAG')]
        property StatusEnvioEcommerce: string read FStatusEnvioEcommerce write SetStatusEnvioEcommerce;

        [TPersistable(fgPersistable, 'Z3_VLRFRE')]
        property ValorFreteTodimoTransporte: double read FValorFreteTodimoTransporte write SetValorFreteTodimoTransporte;

        [TPersistable(fgPersistable, 'Z3_STATUS')]
        property StatusLiberacaoEntregaFutura: string read FStatusLiberacaoEntregaFutura write SetStatusLiberacaoEntregaFutura;

        [TPersistable(fgPersistable, 'Z3_CONFVEN')]
        property UsuarioQueBloqueouOrcamento: string read FUsuarioQueBloqueouOrcamento write SetUsuarioQueBloqueouOrcamento;

        /// <summary>
        /// Para NFE = '', outros = '1'
        /// </summary>
        [TPersistable(fgPersistable, 'Z3_MOEDA')]
        property Moeda: double read FMoeda write SetMoeda;

        [TPersistable(fgPersistable, 'Z3_PLACA')]
        property PlacaTransportadora: string read FPlacaTransportadora write SetPlacaTransportadora;

        [TPersistable(fgPersistable, 'Z3_UFPLACA')]
        property UFPlancaTransportadora: string read FUFPlancaTransportadora write SetUFPlancaTransportadora;

        [TPersistable(fgPersistable, 'Z3_VEIPESQ')]
        property CodigoVeiculoTransportadora: string read FCodigoVeiculoTransportadora write SetCodigoVeiculoTransportadora;

        [TPersistable(fgPersistable, 'Z3_BRICMS')]
        property BaseICMSRestido: double read FBaseICMSRestido write SetBaseICMSRestido;

        /// <summary>
        /// Precisamos ver qual é a necessidade desse campo
        /// preenchido no 8-eok e 4-fat da venda futura
        /// </summary>
        [TPersistable(fgPersistable, 'Z3_TIPO')]
        property Tipo: string read FTipo write SetTipo;

        [TPersistable(fgUpdateable, 'D_E_L_E_T_')]
        property Delete: string read FDelete write SetDelete;

        [TPersistable(fgPersistable, 'R_E_C_N_O_')]
        property Recno: integer read FRecno write SetRecno;

        [TPersistable(fgReadOnly, 'R_E_C_D_E_L_')]
        property RecnoDelete: integer read FRecnoDelete write SetRecnoDelete;

        [TPersistable(fgPersistable, 'Z3_VERSAO')]
        property VersaoSistema: string read GetVersaoSistema write SetVersaoSistema;

        [TPersistable(fgPersistable, 'Z3_ENTRADA')]
        property ValorEntrada: double read FValorEntrada write SetValorEntrada;

        /// <summary>
        /// Propriedade que indica ao copiar se a funcção de CopiarPara irá
        /// fazer a cópia completa das informações (itens, codicao pagamento
        /// etc) ou somente o cabeçalho
        /// </summary>
        /// <value>
        /// será setada como verdadeira na instância da classe
        /// </value>
        property CopiaCompleta: boolean read FCopiaCompleta write SetCopiaCompleta;

        /// <summary>
        /// propriedade usada na integração com o microssiga para gravar na
        /// tabela Z80  Cupom Fiscal = 4, Nota Fiscal = 1
        /// </summary>
        property TipoNotaFiscalMicrossiga: string read FTipoNotaFiscalMicrossiga write SetTipoNotaFiscalMicrossiga;

        /// <summary>
        /// Baseado na propiedade TipoNotaFiscalMicrossiga pode ser 'C' = cupom discal ou 'N' = nota fiscal
        /// </summary>
        property CupomOuNotaFiscal: string read GetCupomOuNotaFiscal;

        /// <summary>
        /// Propriedade utilizada para guardar o codigo da estação do
        /// Microsiga, este valor vem da tabela SLG
        /// </summary>
        property CodigoEstacaoMS: String read FCodigoEstacaoMS write SetCodigoEstacaoMS;

        property NumeroIdentificacaoTef: string read FNumeroIdentificacaoTef write SetNumeroIdentificacaoTef;

        /// <summary>
        /// Properiedade que indica que se o orcamento tem tabela (T1, T2,
        /// T3.. etc);
        /// </summary>
        property OrcamentoComTabela: boolean read GetOrcamentoComTabela;

        /// <summary>
        /// Properiedade que indica que se o orcamento tem algum item com
        /// preço negociado
        /// </summary>
        property OrcamentoComPrecoNegociado: boolean read GetOrcamentoComPrecoNegociado;

        /// <summary>
        /// Properiedade que indica que se o orcamento tem algum item que
        /// seja da SelfColor
        /// </summary>
        property OrcamentoComProdutoSelf: boolean read GetOrcamentoComProdutoSelf;

        property StatusConferencia: TStatusConferencia read GetStatusConferencia;

        property TabelaComissao: TTabelaComissao read FTabelaComissao write SetTabelaComissao;
        property TabelaComissaoQuantidadeParcelas: integer read FTabelaComissaoQuantidadeParcelas write SetTabelaComissaoQuantidadeParcelas;

        property TipoEntregaPadrao: TTipoEntrega read GetTipoEntregaPadrao;

{$ENDREGION}
        function Inserir: integer; override;
        function Alterar: integer; override;
        function Deletar(ID: string): integer; override;
        function Listar(tipoOperacao: TOparationTypes; multiSelect: boolean; paramentro: TParametro): TResultFilter; overload;
        function Listar(tipoOperacao: TOparationTypes; multiSelect: boolean): TResultFilter; overload; override;
        function Obter(ID: string): TObject; overload; override;
        function Obter(parametros: TParametro): TObject; overload;

        /// <summary>
        /// retorna o Número do Orcamento
        /// </summary>
        procedure ObterNumeroOrcamento;

        /// <summary>
        /// Popula o objeto Orcamento
        /// </summary>
        procedure PopularObjeto(Orcamento: TOrcamento);

        /// <summary>
        /// Popula o objeto parametro passado.
        /// </summary>
        /// <param name="numeroOrcamentoInserir">
        /// Numero de identificação do orcamento filho para sabermos qual
        /// orcamento dentro do parametro iremos inserir, esta marcação vai
        /// no processo do parametro para o servidor. (SZ3,SZ6...)
        /// </param>
        function ObterParametrosInsercao(var parametro: TParametro; numeroOrcamentoInserir: string): TParametro;

        /// <summary>
        /// popula todos os totais do orcamento e totais dos impostos
        /// </summary>
        procedure ObterTotaisOrcamento;

        /// <summary>
        /// Zero todos os totais do orcamento
        /// </summary>
        procedure ZerarTotais;

        /// <summary>
        /// desmembra orcamento mae em seus orcamentos filhos, de acordo com
        /// o tipo de entrega de cada item
        /// </summary>
        procedure DesmembrarOrcamento;

        /// <summary>
        /// Obtém o orcaemento da loja dos orcamento filhos - 8-EOK
        /// </summary>
        function ObterOrcamentoLoja: TOrcamento;

        /// <summary>
        /// Obtém o orcaemento filho por tipo
        /// </summary>
        function ObterOrcamentoFilhoPorTipo(TipoOrcamento: string): TOrcamento;

        /// <summary>
        /// Este método retorna a quantidade de orçamentos que são entregues
        /// fora da loja.
        /// </summary>
        function VerificarQuantidadeItensForaDaLoja: integer;

        /// <summary>
        /// Obter numero do cupom fiscal eletronico
        /// </summary>
        function ObterNumeroCupomFiscalEletronico: string; deprecated;

        /// <summary>
        /// Obter a serie do cupom fiscal eletronico
        /// </summary>
        function ObterSerieCupomFiscalEletronico: string; deprecated;

        /// <summary>
        /// sobrescrita do método da classe base que copia as instancia da
        /// classe (herdada da classe base) bem como as demais propriedades
        /// agregadadas (lista de itens do orcamento, lista de forma de
        /// pagamento, etc).
        /// </summary>
        procedure CopiarPara(objeto: TObject); override;

        /// <summary>
        /// Obtem os itens e popula os itens do orcamento
        /// </summary>
        procedure ObterItensOrcamento;

        /// <summary>
        /// obtem lista de condição de pagamento do orcamento;
        /// </summary>
        procedure ObterCondicaoPagamentoOrcamento;

        /// <summary>
        /// obtem os orcamentos filhos;
        /// </summary>
        procedure ObterOrcamentosFilhos;

        /// <summary>
        /// Lista todos os orcamentos liberados do dia e retorna um escolhido pelo usuário
        /// </summary>
        function ObterOrcamentosLiberadosDoDia: TOrcamento;

        /// <summary>
        /// Bloqueia o orcameto para que possa fazer a alteração sem que
        /// nenhum outro usuário possa usá-lo
        /// </summary>
        procedure BloquearOrcamento;

        /// <summary>
        /// Libera o orçamento para que todos possam alterá-lo
        /// </summary>
        procedure LiberarOrcamento;

        /// <summary>
        /// Popula algumas informações do vendedor necessárias no orcamento
        /// </summary>
        procedure PopularVendedorAoOrcamento(Vendedor: TVendedor);

        /// <summary>
        /// Popular informações do cliente necessárias no orcamento
        /// </summary>
        procedure PopularClienteAoOrcamento(Cliente: TCliente);

        /// <summary>
        /// Obtem orcamento para conferencia, somente com itens para a loja
        /// </summary>
        procedure ObterOrcamentoParaConferencia;

        /// <summary>
        /// efetua a conferencia do produto passado,
        /// </summary>
        /// <returns>
        /// <para>
        /// Retorna o codigo do produto
        /// </para>
        /// </returns>
        function ConferirProduto(produto: string; quantidade, quantidadeMinima: double): string;

        /// <summary>
        /// Grava um arquivo ORCCONF.txt no diretorio da aplicação com os produtos conferidos
        /// </summary>
        procedure GravarItensConferidos;

        /// <summary>
        /// Restura Itens conferidos do arquivo ORCCONF.txt no diretorio da aplicação.
        /// </summary>
        procedure RestauraItensConferidos;

        /// <summary>
        /// valida a conferencia do produto
        /// </summary>
        /// <param name="produto">
        /// produto a conferir
        /// </param>
        /// <param name="item">
        /// retorna o item do ocamento
        /// </param>
        /// <returns>
        /// valida se pode ou não conferir
        /// </returns>
        function ValidarConferencia(produto: string; out item: TOrcamentoItens): boolean;

        /// <summary>
        /// Obtem o total de itens já conferidos
        /// </summary>
        function ObterTotalItensConferidos: integer;

        /// <summary>
        /// Obtem a quantidade de itens para conferencia
        /// </summary>
        function ObterQuantidadeItensConferencia: integer;

        /// <summary>
        /// retorna a listade itens para conferencia
        /// </summary>
        function ObterListaDeItensParaConferencia: TList;

        procedure CalcularValorEntradaPagamento(valorRateio: double);
        procedure ObterValorParaRateio(var valorDosProduto: double; var tipos: String; tipoDoRateio: TTipoDeRateio);
        procedure RatearValoresNosItens(valorRateio: double; nomeCampoParaRateio: String; tipoDoRateio: TTipoDeRateio); overload;
        procedure RatearValoresNosItens; overload;
        function ZerarRateioValoresNosItens(nomeCampoParaRateio: String): boolean;
        function ObterTotalProdutosDiferenteDeCursoSeguro(var tipos: String): double;
        function ObterTotalPorTipoParaRateio(Tipo: String; var tiposDeEntrega: string): double;
        procedure AtualizarTabelaComissaoItens;
        function ObterValorRestanteParaPagamento: double;

        procedure MostrarArvoreProdutosAlternativos(item: TOrcamentoItens = nil);

        constructor Create; overload;
        constructor Create(tipoVda: TTipoVenda); overload;
        destructor Destroy; override;

{$ENDREGION}
{$REGION 'Itens do Orcamento'}
        property OrcamentoItens: TLista<TOrcamentoItens> read FOrcamentoItens;

        /// <summary>
        /// Guarda o último item alterado ou inserido da lista
        /// </summary>
        property UltimoItemAlterado: TOrcamentoItens read FUltimoItemAlterado write SetUltimoItemAlterado;

        /// <summary>
        /// Retorna a quantidade de itens
        /// </summary>
        function ObterQuantidadeItens: integer;

        /// <summary>
        /// Obtem o total das quantidade de todos os itens.
        /// </summary>
        function ObterQuantidadeTotalItens: double;

        /// <summary>
        /// Obtém o peso total de todos os items
        /// </summary>
        function ObterPesoTotalItens: double;

        /// <summary>
        /// Adiciona item na lista de itens
        /// </summary>
        procedure AddOrcamentoItem(OrcamentoItens: TOrcamentoItens); overload;

        /// <summary>
        /// Adiciona Item na lista de Itens através de um produto
        /// </summary>
        procedure AddOrcamentoItem(produto: TProduto; quantidade: double = 0; tipoEntrega: string = 'LJ'); overload;

        /// <summary>
        /// Pesquisa um ou mais produto e adiciona ao orcamento.
        /// </summary>
        procedure AddOrcamentoItemPesquisandoProduto(produto: String);

        /// <summary>
        /// Deleta item da lista de itens
        /// </summary>
        function DeletarOrcamentoItem(item: TOrcamentoItens; mostraMensagem: boolean = false): boolean;

        /// <summary>
        /// Limpa todos os itens do orcamento
        /// </summary>
        procedure LimparItensDoOrcamento;

        /// <summary>
        /// Obtem item por código e validaConferencia da lista de itens do orcamento
        /// </summary>
        /// <param name="entrega">
        /// ex: DL, LJ...
        /// </param>
        function ObterItem(codigo: string; validaConferido: boolean; tipoEntrega: string): TOrcamentoItens; overload;
        function ObterItem(codigo: string; validaConferido: boolean): TOrcamentoItens; overload;
        function ObterItem(codigo: string; tipoEntrega: string): TOrcamentoItens; overload;
        function ObterItem(codigo: string): TOrcamentoItens; overload;

        /// <summary>
        /// obtem a quantidade item conforme o tipo de entrega (DL, LJ)
        /// passado por parametro
        /// </summary>
        /// <param name="entrega">
        /// tipo de entrega (DL, LJ)
        /// </param>
        function ObterQuantidadeItemPorTipoEntrega(entrega: string): integer;

        /// <summary>
        /// faz a somatoria dos impostos da dilma calculados item a item
        /// </summary>
        function ObterTotalDosImpostosDilma: double;

        /// <summary>
        /// recalcula todos os impostos de todos os itens do orcamento.
        /// </summary>
        procedure RecalcularImpostoItens;

        /// <summary>
        /// Recalcula todos as comissões aplicadas de todos os itens
        /// </summary>
        procedure RecalcularComissoesAplicadas;

        /// <summary>
        /// Métdo que atualizar as tabelas de comissões dos itens.
        /// </summary>
        procedure AtualizarTabelasDeComissao;

        /// <summary>
        /// Atualiza o numero do cupom fiscal nos orcamentos filhos.
        /// </summary>
        /// <param name="numeroDocumento">
        /// numero cupom fical
        /// </param>
        procedure AtualizarNumeroDocumentoNosItens(NumeroDocumento, serie: string);

        /// <summary>
        /// Verifica se existe algum item com caracters inválidos
        /// </summary>
        function ValidarCaracteresInvalidosNosItens: boolean;

        function ObterTotalPrecoTabela: double;
        procedure RecalcularPrecoEmTabelaComissao;
        procedure ZerarPrecoEmTabela;

        procedure AbrirTelaCursoSeguro(item: TOrcamentoItens);

        function ObterCrossSelling(item: TOrcamentoItens): boolean;
        function ObterUpSelling(item: TOrcamentoItens): boolean; overload;
        function ObterUpSelling(produto: TProduto): boolean; overload;
        function ObterSimilares(item: TOrcamentoItens): boolean; overload;
        function ObterSimilares(produto: TProduto): boolean; overload;

        procedure AtualizarFilhosCrossSelling(itemAtual, itemAnterior: TOrcamentoItens);

{$ENDREGION}
{$REGION 'Condições de Pagamento'}
        property OrcamentoPagamento: TLista<TOrcamentoPagamento> read FOrcamentoPagamento;

        /// <summary>
        /// Adiciona condição de pagamento
        /// </summary>
        procedure AddOrcamentoPagto(OrcamentoPagto: TOrcamentoPagamento);

        /// <summary>
        /// Gera as parcelas de uma determinada condição de pagamento de
        /// acordo com os paramentros passados
        /// </summary>
        function GerarParcelas(formaPagamento_GP: TFormaPagamento; administradora_GP: TAdministradora; valorTotal_GP: double;
            quantidadeParcelas_GP: integer; primeiraDataVcto_GP: string; tipoGeracaoParcela_GP: TTipoGeracaoParcela; dias_GP, intervalo_GP: integer;
            tipoCheque_GP, agenciaBanco_GP, conta_GP, numeroDocumento_GP, nomeCliente_GP, rg_GP, cgc_GP, telefone_GP, observacao_GP: string)
            : boolean; overload;

        /// <summary>
        /// Gera as parcelas de uma determinada condição de pagamento de
        /// acordo com os paramentros passados
        /// </summary>
        function GerarParcelas(formaPagamento_GP: TFormaPagamento; administradora_GP: TAdministradora; valorTotal_GP: double;
            quantidadeParcelas_GP: integer; primeiraDataVcto_GP: string; tipoGeracaoParcela_GP: TTipoGeracaoParcela; dias_GP, intervalo_GP: integer)
            : boolean; overload;

        /// <summary>
        /// Cancela as parcelas de uma determinada condição de pagamento
        /// </summary>
        procedure CancelarCondicaoPagamento(formaPg: TFormaPagamento; administradora, sequenciamentoCartao: string);

        /// <summary>
        /// Obtém o valor total de uma determinada condição de pagamento.
        /// </summary>
        function ObterValorTotalCondicaoPagamento(formaPg: TFormaPagamento; administradora, sequenciamentoCartao: string): double; overload;
        function ObterValorTotalCondicaoPagamento(condicaoPgto: TOrcamentoPagamento): double; overload;
        function ObterValorTotalCondicaoPagamento(formaPg: TFormaPagamento): double; overload;

        /// <summary>
        /// Obtem o total de parcelas das condições de pagamento
        /// </summary>
        function ObterTotalParcelas(condicaoPgto: TOrcamentoPagamento): integer;

        /// <summary>
        /// Obtem o valor total de todas as condições de pagamento
        /// </summary>
        function ObterValorTotalTodasCondicoesPagamento: double;

        /// <summary>
        /// Retorna a quantidade de condicao Pagamento
        /// </summary>
        function ObterQuantidadeCondicaoPagamento: integer;

        /// <summary>
        /// Limpa todas as condições de pagamento
        /// </summary>
        procedure LimparCondicoesPagamento;

        /// <summary>
        /// percorre as condições de pagamento e retorna o prazo medio
        /// </summary>
        function ObterPrazoMedioDasCondicoesPagto: double;

        /// <summary>
        /// Altera as informações das parcelas seguintes da condição de
        /// pagamento de acordo com condicao alterada
        /// </summary>
        procedure AlterarParcelasDaMesmaCondicaoPagamento(condicaoPgto: TOrcamentoPagamento);

        /// <summary>
        /// Retorna a condição de pagamento que possui a maior parcela
        /// </summary>
        function ObterCondicaoPagamentoComMaiorParcela: TOrcamentoPagamento;

        /// <summary>
        /// Verifica se existe parcela em atraso
        /// </summary>
        function VeriricarExistenciaParcelasVencidas: boolean;
{$ENDREGION}
{$REGION 'Curso e Seguro'}
        /// <summary>
        /// Este método atualizada as informações do movimento e seguro, tais como
        /// valores de comissão e numero e série de range
        /// </summary>
        procedure AtualizarMovimentoCursoSeguro;

        /// <summary>
        /// Este método atualizada as informações do movimento e seguro, tais como
        /// valores de comissão e numero e série de range
        /// </summary>
        procedure ObterInformacoesMovimentoCursoSeguro(item: TOrcamentoItens);

        /// <summary>
        /// imprime os contratos dos cursos caso exista
        /// </summary>
        procedure ImprimirTermoAdesaoCursoSeguro;

        /// <summary>
        /// quantidade de itens curso e seguro
        /// </summary>
        function ObterQuantidadeItensCursoSeguro: integer;

{$ENDREGION}
{$REGION 'Orcamentos Filhos'}
        property OrcamentosFilhos: TLista<TOrcamento> read FOrcamentosFilhos write SetOrcamentosFilhos;

        /// <summary>
        /// Verifica se existe orcamento filho com itens para entrega.
        /// usar metódo VerificarQuantidadeItensForaDaLoja
        /// </summary>
        function VerificarExistenciaOrcamentoParaEntrega: boolean; deprecated;

        /// <summary>
        /// Verifica a quantiade de orcamento filhos
        /// </summary>
        function ObterQuantidadeOrcamentoFilhos: integer;

        function SelecionarTipoEntrega(item: TOrcamentoItens): TTipoEntrega;
{$ENDREGION}
{$REGION 'CreditosClinte'}
        property CreditosCliente: TLista<TCreditoCliente> read FCreditosCliente write SetCreditosCliente;
        procedure AdicionarCreditoCliente(credito: TCreditoCliente);
        function ConsultarCreditosCliente: boolean;
{$ENDREGION}
    end;

implementation

uses Lib.Filter, Datasnap.DBClient, Lib.Aguarde,
    System.Types, forms, System.UITypes;


{ TOrcamento }

{$REGION 'Métodos CRUD'}

procedure TOrcamento.ImprimirTermoAdesaoCursoSeguro;
var
    item: TOrcamentoItens;
    xml: WideString;
    param: TParametro;
    cpf, data: string;
    itemParam: TItemParametro;
    aux: string;
begin
    try
        param := nil;
        for item in Self.OrcamentoItens do
        begin
            if item.tipoEntrega = 'CS' then
            begin
                if not item.produto.preenchido then
                    item.produto.Obter(item.CodigoProduto);

                param := item.MovimentoCursoSeguro.ObjetoParaParametros(acNenhumaAcao);

                if item.produto.TipoProduto = tpCurso then
                begin
                    param.add('', 'DATAATUAL', Tlib.ObterDataAtual('dd/mm/yyyy'), '1');

                    // Formatar valor
                    itemParam := param.ObterItemParamentroPorNome('ZJA_CPF');
                    itemParam.Valor := copy(itemParam.Valor, 1, 3) + '.' + copy(itemParam.Valor, 4, 3) + '.' + copy(itemParam.Valor, 7, 3) + '-' +
                        copy(itemParam.Valor, 10, 2);
                    //
                    itemParam := param.ObterItemParamentroPorNome('ZJA_DTEMIS');
                    itemParam.Valor := copy(itemParam.Valor, 7, 2) + '/' + copy(itemParam.Valor, 5, 2) + '/' + copy(itemParam.Valor, 1, 4);
                    //
                    xml := baseLib.ParametroToXMLRetorno(param);
                    TRelatorio.ExecutarRelatorio(tiCliente, 'TermoAdesaoCurso', xml);
                end
                else
                begin
                    aux := TConverteEnum<TTipoSeguro>.ToString(item.produto.CursoSeguro.TipoSeguro_);
                    xml := baseLib.ParametroToXMLRetorno(param);
                    TRelatorio.ExecutarRelatorio(tiCliente, aux, xml);
                end;
            end;
        end;
    finally
        if param <> nil then
            FreeAndNil(param);
    end;
end;

function TOrcamento.Inserir: integer;
var
    parametro: TParametro;
    i: integer;
begin
    try
        parametro := TParametro.Create;
        ObterParametrosInsercao(parametro, EmptyStr);
        baseLib.ExecutaTarefa('InserirOrcamento', 'TOrcamento', parametro);

        // ###Validar retorno da função
        result := 0;
    finally
        if parametro <> nil then
            FreeAndNil(parametro);
    end;
end;

procedure TOrcamento.AbrirTelaCursoSeguro(item: TOrcamentoItens);
begin


end;

procedure TOrcamento.AddOrcamentoItem(produto: TProduto; quantidade: double; tipoEntrega: string);
var
    item: TOrcamentoItens;
    idade, numeroTentativas: integer;
    tipoSeguro: string;
    numeroDeSerieHidrometro: string;
begin
    if not produto.ProdutoAtivo then
        raise Exception.Create('Produto não esta ativo.');

    if produto.PrecoAtualProduto = 0 then
        raise Exception.Create('Produto está sem preço cadastrado.');

    if produto.TipoProduto = tpCurso then
        raise Exception.Create('Produto do tipo Curso não validado.');

    if Self.TipoVenda <> tvVendaRapida then
    begin
        if TipoEntregaPadrao = nil then
            raise Exception.Create('Erro ao pegar Local de entrega.');

        tipoEntrega := TipoEntregaPadrao.tipoEntrega;

        if produto.ProdutoEmPromocao then
            Tlib.MensagemInformacao('O Produto..:' + produto.Descricao + ' esta em Promoção '#13 + #13 + 'Promoção Válida para o dia: ' +
                produto.DataInicioPromocao + '   Até   ' + produto.DataFimPromocao + #13 + #13 + 'De  R$: ' + FormatFloat('###,###,##0.00',
                produto.PrecoTabelaProduto) + '   Por   R$:' + FormatFloat('###,###,##0.00', produto.PrecoPromocao));
    end;

    if (produto.TipoProduto <> tpNormal) and (produto.ProdutoSobEncomenda) then
        raise Erro.Create('Tipo do produto ' + TConverteEnum<TTipoProduto>.ToString(produto.TipoProduto) + ', não pode ser sob encomenda.',
            MSGInformacao);

    if (produto.ProdutoLiberadoConferenciaFiscal = false) and (produto.ProdutoSobEncomenda = false) then
        raise Exception.Create('Produto não conferido dados fiscais, contate o departamento de compras.');

    if (produto.ProdutoLiberadoConferenciaFiscal = false) then
        tipoEntrega := 'PE';

    // validar futuramento pelo Tipo de Produto;
    if produto.ProdutoHidrometro then
    begin
        if Self.TipoVenda = tvVendaRapida then
        begin
            raise Exception.Create('Não é possivel inserir produto do tipo Hidrômetro no caixa, Favor solicitar ao vendedor um orçamento.');
        end
        else
        begin
            numeroTentativas := 0;
            while (numeroTentativas <= 3) and (numeroDeSerieHidrometro = '') do
            begin
                Inc(numeroTentativas);
                numeroDeSerieHidrometro := Tlib.MensagemCaixaEntrada<string>('Este Produto tem Numero de Séríe' + #13 +
                    'utilizado pela Companhia de Abastecimento,'#13 + 'e deve constar na Nota Fiscal...'#13 +
                    'A série é formada por letras e números'#13 + 'totalizando 10 caracteres. Exemplo.: A04F019082', 'Hidrômetro', mtString);

                if Length(numeroDeSerieHidrometro) = 10 then
                begin
                    numeroDeSerieHidrometro := '[N.S: ' + numeroDeSerieHidrometro + ']';
                    numeroTentativas := 3
                end
                else
                begin
                    numeroDeSerieHidrometro := '';
                end;
            end;

            if numeroDeSerieHidrometro = EmptyStr then
            begin
                raise Exception.Create('Não é possivel inserir produto do tipo Hidrômetro sem número de série!');
            end;
        end;
    end;

    if not produto.ValidarCaracteresInvalidosDescricao then
        raise Exception.Create('Caracteres inválidos.');

    // Validação de seguro
    if produto.TipoProduto = tpSeguro then
    begin
        produto.CursoSeguro.Obter(produto.CodigoCursoSeguro);
        if not produto.CursoSeguro.preenchido then
            raise Exception.Create('Nenhum curso ou seguro vinculado a esse produto');

        if not produto.CursoSeguro.VendaCaixa_ then
            raise Exception.Create('Este curso ou seguro não esta validado para vender no Caixa');

        if Self.ObterQuantidadeItensCursoSeguro - Self.ObterQuantidadeTotalItens <> 0 then
            raise Exception.Create('Curso e Seguro não podem ser vendidos com outros tipos de produtos.');

        if ((Self.Cliente.codigo = Self.Cliente.CodigoClientePadrao) and (Self.Cliente.Sequencial = Self.Cliente.SeguencialClientePadrao)) and
            (produto.CursoSeguro.VendaConsumidorFinal_ = false) then
            raise Exception.Create('Este curso/seguro não esta validado para vender para consumidor final.');

        if (Self.Cliente.preenchido = false) or (Self.Cliente.TipoPessoa_ <> tpPessoaFisica) then
            raise Exception.Create('Cursos e seguros só podem ser vendidos para pessoa física.');

        if (produto.TipoProduto = tpSeguro) then
        begin
            idade := 0;
            // if produto.CursoSeguro.TipoSeguro_ = tsResidencial then
            // begin
            // if (Self.Cliente.idade > 65) or (Self.Cliente.idade < 18) then
            // idade := 65;
            // end
            // else
            // begin
            if (Self.Cliente.idade > 70) or (Self.Cliente.idade < 18) then
                idade := 70;
            // end;

            if idade > 0 then
            begin
                tipoSeguro := TConverteEnum<TTipoSeguro>.ToString(produto.CursoSeguro.TipoSeguro_);
                raise Exception.Create('Cliente precisa ter idade entre 18 e ' + inttostr(idade) + ' anos para venda de seguro: ' + tipoSeguro);
            end;
        end;

        if not Tlib.SistemaEstaEmModoDebug then
            if (Self.Vendedor.codigo <> TUsuarioLogado.ObterInstancia.Vendedor) then
                raise Exception.Create('Só é possível faturar cursos/seguros com vendedor que seja vinculado ao usuário logado. (' +
                    TUsuarioLogado.ObterInstancia.Vendedor + ')');
    end
    else
    begin
        if Self.ObterQuantidadeItensCursoSeguro > 0 then
            raise Exception.Create('Já existem produtos que são de curso e seguro.');

        if Self.TipoVenda = tvVendaRapida then
            if (Self.Vendedor.codigo = TUsuarioLogado.ObterInstancia.Vendedor) then
                raise Exception.Create('Não é possível faturar vendas normais com vendedor que seja vinculado ao usuário logado. (' +
                    TUsuarioLogado.ObterInstancia.Vendedor + ')');
    end;

    if quantidade = 0 then
        quantidade := produto.QtdMultiplaVenda;

    // verifica se o item já foi adicionado somente para venda rápida (Caixa).
    item := Self.ObterItem(produto.codigo);
    if (item <> nil) then
    begin
        if Self.TipoVenda = tvVendaRapida then
        begin
            item.quantidade := item.quantidade + quantidade;
            item.ValorTotal := Tlib.ArredondarNumero((item.quantidade * item.ValorUnitario));
            item.Tabela := trim(Self.Vendedor.TabelaComissao);
            UltimoItemAlterado := item;
            exit;
        end
        else
        begin
            if (produto.ProdutoHidrometro = false) and (produto.ProdutoSelfColor = false) and (produto.TipoProduto <> tpSeguro) then
            begin
                tipoEntrega := SelecionarTipoEntrega(item).tipoEntrega;

                if tipoEntrega = '' then
                    raise Exception.Create('Nenhum tipo de entrega selecionado');
            end;
        end;
    end;

    item := TOrcamentoItens.Create;
    // Obtem a filial
    item.Filial := Self.Filial_.Filial;
    item.Filial_ := Self.Filial_;

    item.CodigoProduto := produto.codigo;
    item.DescricaoProduto := produto.Descricao;
    item.quantidade := quantidade;
    item.PrecoTabela := produto.PrecoAtualProduto;
    item.ValorUnitario := produto.PrecoAtualProduto;

    if Self.TipoVenda <> tvVendaRapida then
        item.Tabela := TabelaComissao.CodigoTabela // trim(Self.Vendedor.TabelaComissao); // 'T1';
    else
    begin
        item.Tabela := 'T1';
    end;

    item.UnidadeMedida := produto.UnidadeMedidaEmbalagem;
    item.DataEmissao := Tlib.ObterDataAtual;

    // Obtem o numero do item do orcamento
    item.item := Tlib.ColocarZeroEsquerda(2, inttostr(FOrcamentoItens.Count + 1));

    produto.CopiarPara(item.produto);

    if produto.ProdutoSelfColor then
    begin
        if Self.TipoVenda = tvVendaRapida then
        begin
            // validar futuramento pelo Tipo de Produto;
            raise Exception.Create('Não é possivel inserir produto do tipo Self color no caixa, Favor solicitar ao vendedor um orçamento.');
        end
        else
        begin
            if Tlib.AbrirFormulario(TfrmCadSelfColor, acAlteracao, item) <> rfOK then
                exit;

            item.PrecoTabela := item.ValorUnitario;
        end;
    end;

    if item.produto.TipoProduto = tpSeguro then
    begin
        item.tipoEntrega := 'CS';
        item.MovimentoCursoSeguro.Nome := Self.Cliente.Nome;
        item.MovimentoCursoSeguro.cpf := Self.Cliente.cgc;
        item.MovimentoCursoSeguro.Endereco := Self.Cliente.Endereco;
        item.MovimentoCursoSeguro.Estado := Self.Cliente.Estado;
        item.MovimentoCursoSeguro.Cep := Self.Cliente.Cep;
        item.MovimentoCursoSeguro.Bairro := Self.Cliente.Bairro;
        item.MovimentoCursoSeguro.Cidade := Self.Cliente.Municipio;

        item.MovimentoCursoSeguro.DataNascimento := Self.Cliente.DataNascimento;

        // pego as irformações iniciais de seguro
        if item.produto.TipoProduto = tpSeguro then
        begin
            Self.AbrirTelaCursoSeguro(item);
        end;
    end
    else
        item.tipoEntrega := tipoEntrega;

    // item.TipoEntrega_ := Self.Filial_.ObterTipoEntrega(item.tipoEntrega);

    item.CustoGerencial := produto.CustoGerencial;
    item.CodigoVendedor := Self.CodigoVendedor;
    item.Vendido := '';
    item.UsuarioSistema := TUsuarioLogado.ObterInstancia.Login;
    item.TipoVenda := Self.TipoDaVenda;

    if produto.ProdutoHidrometro then
        item.FormulaSelfColor := numeroDeSerieHidrometro;

    UltimoItemAlterado := item;

    if not Self.Cliente.preenchido then
        Self.Cliente.Obter(Self.SequencialCliente, Self.CodigoCliente);

    // Calcula Imposto
    // item.CalcularImposto(self.Cliente.Estado, self.Cliente.Tipo, self.Cliente.TipoPessoa, self.TipoDaVenda, self.CupomOuNotaFiscal);

    if Self.TipoVenda <> tvVendaRapida then
    begin
        item.CalcularPrecoEmTabela(TabelaComissao, TabelaComissaoQuantidadeParcelas, ObterTotalPrecoTabela, Self.ValorEntrada);
    end;

    { Preenche Campanha e/ou status produto }
    item.Campanha := '';
    item.Campanha := item.produto.ProdutoEmCampanha_;
    if produto.ProdutoEmPromocao then
        item.Campanha := item.Campanha + 'X/';
    if produto.ProdutoForaLinha then
        item.Campanha := item.Campanha + 'F/';
    if produto.ProdutoSobEncomenda then
        item.Campanha := item.Campanha + 'E/';

    item.PaiAlternativo := false;

    FOrcamentoItens.add(item);
    RatearValoresNosItens;

    { Limpar Condições de pagamento }
    { Somar Totais do Orçamento }
end;

procedure TOrcamento.AddOrcamentoItemPesquisandoProduto(produto: String);
var
    prod: TProduto;
    resultado: TResultFilter;
    i: integer;
begin
    try
        prod := TProduto.Create;
        if StrToInt64Def(produto, -1) <> -1 then
        begin
            // Pesquisa produto por codigo ou codigo de barras
            if prod.Obter(produto) <> nil then
            begin
                // Venda direto no caixa não mostra produtos alternativos
                if Self.TipoVenda <> tvVendaRapida then
                begin
                    // Se selecionado produto sem preço, indica que usuário quer ver os produtos alternativos
                    if prod.PrecoAtualProduto = 0 then
                    begin
                        if Tlib.MensagemPergunta('Produto ' + prod.Descricao + ' esta sem preço'#13 + 'Deseja visualizar produtos alternativos',
                            'Produtos Alternativaos') = mrYes then
                        begin
                            if not Self.ObterUpSelling(prod) then
                                if not Self.ObterSimilares(prod) then
                                    Tlib.MensagemInformacao('Este produto não possui produtos alternatinativos', 'Produtos Alternativos');
                        end;
                        exit;
                    end;
                end;

                Self.AddOrcamentoItem(prod, 0);
                if Self.TipoVenda <> tvVendaRapida then
                begin
                    if not((Self.Filial_.UpSelling_) and (Self.ObterUpSelling(Self.UltimoItemAlterado))) then
                        if (Self.Filial_.Similar_) then
                            Self.ObterSimilares(Self.UltimoItemAlterado);

                    if Self.Filial_.CrossSelling_ then
                        Self.ObterCrossSelling(Self.UltimoItemAlterado);
                end;
            end;
        end
        else
        begin
            resultado := prod.Listar(otSelect, True, produto);
            if resultado.List.Count <> 0 then
            begin
                for i := 0 to resultado.List.Count - 1 do
                begin
                    prod := TProduto(resultado.List[i]);
                    try
                        if Self.TipoVenda <> tvVendaRapida then
                        begin
                            if prod.PrecoAtualProduto = 0 then
                            begin
                                if Tlib.MensagemPergunta('Produto ' + prod.Descricao + ' esta sem preço'#13 +
                                    'Deseja visualizar produtos alternativos', 'Produtos Alternativaos') = mrYes then
                                begin
                                    if not Self.ObterUpSelling(prod) then
                                        if not Self.ObterSimilares(prod) then
                                            Tlib.MensagemInformacao('O produto ' + prod.Descricao + ' não possui produtos alternatinativos',
                                            'Produtos Alternativos');
                                end;

                                continue;
                            end;
                        end;

                        Self.AddOrcamentoItem(prod, 0);

                        if Self.TipoVenda <> tvVendaRapida then
                        begin
                            if not((Self.Filial_.UpSelling_) and (Self.ObterUpSelling(Self.UltimoItemAlterado))) then
                                if (Self.Filial_.Similar_) then
                                    Self.ObterSimilares(Self.UltimoItemAlterado);

                            if Self.Filial_.CrossSelling_ then
                                Self.ObterCrossSelling(Self.UltimoItemAlterado);
                        end;
                    except
                        on e: Exception do
                        begin
                            Tlib.MensagemErro('Erro ao inserir item', e.Message);
                        end;
                    end;
                end;
            end;
        end;
    finally
        if prod <> nil then
            FreeAndNil(prod);
    end;
end;

procedure TOrcamento.PopularVendedorAoOrcamento(Vendedor: TVendedor);
begin
    Vendedor.CopiarPara(Self.Vendedor);
    Self.CodigoVendedor := Vendedor.codigo;
    Self.NomeVendedor := Vendedor.NomeReduzido;
end;

procedure TOrcamento.PreencherTreeView(treeView: TTreeView);
var
    itemOrc: TOrcamentoItens;
    pai, filho: String;
begin
    treeView.Items.Clear;
    for itemOrc in Self.OrcamentoItens do
    begin
        if (itemOrc.PaiAlternativo) or (itemOrc.ProdutoPaiAlternativo <> nil) then
        begin
            filho := itemOrc.CodigoProduto + '-' + itemOrc.LocalEstoque + '-' + itemOrc.TipoEntrega_.tipoEntrega;

            pai := '';
            if itemOrc.ProdutoPaiAlternativo <> nil then
                pai := itemOrc.ProdutoPaiAlternativo.codigo + '-' + itemOrc.LocalEstoquePaiAlternativo + '-' +
                    itemOrc.TipoEntregaPaiAlternativo.tipoEntrega;

            AddTreeView(pai, filho, treeView);
        end;
    end;
end;

function TOrcamento.PreencheTreeViewDeletar(item: TOrcamentoItens; treeView: TTreeView): boolean;
begin
    treeView.Items.Clear;

    AddTreeView('', item.CodigoProduto + '-' + item.LocalEstoque + '-' + item.TipoEntrega_.tipoEntrega, treeView);

    AddTreeViewDeletar(item, treeView);
end;

procedure TOrcamento.PopularClienteAoOrcamento(Cliente: TCliente);
begin
    Cliente.CopiarPara(Self.Cliente);
    Self.CodigoCliente := Cliente.codigo;
    Self.NomeCliente := Cliente.Nome;
    Self.SequencialCliente := Cliente.Sequencial;
    Self.TipoCliente := Cliente.Tipo;
    Self.Endereco := Cliente.Endereco;
    Self.Bairro := Cliente.Bairro;
    Self.Cep := Cliente.Cep;
    Self.Municipio := Cliente.Municipio;
    Self.Estado := Cliente.Estado;
end;

procedure TOrcamento.AddOrcamentoItem(OrcamentoItens: TOrcamentoItens);
begin
    FOrcamentoItens.add(OrcamentoItens);
end;

procedure TOrcamento.AddOrcamentoPagto(OrcamentoPagto: TOrcamentoPagamento);
begin
    FOrcamentoPagamento.add(OrcamentoPagto);
end;

procedure TOrcamento.AddTreeView(pai, filho: String; treeView: TTreeView);
var
    tv, tvs, jatem: integer;
    tem: boolean;
begin
    if pai = '' then
    begin
        treeView.Items.AddChild(nil, filho);
    end
    else
    begin
        for tv := 0 to treeView.Items.Count - 1 do
        begin
            if treeView.Items.item[tv].Text = pai then
            begin
                tem := false;
                for jatem := 0 to treeView.Items.Count - 1 do
                    if treeView.Items.item[jatem].Text = filho then
                        tem := True;

                if tem = false then
                    treeView.Items.AddChild(treeView.Items.item[tv], filho);
            end;

            for tvs := 0 to treeView.Items.item[tv].Count - 1 do
                if treeView.Items.item[tv].item[tvs].Text = pai then
                begin
                    tem := false;
                    for jatem := 0 to treeView.Items.item[tv].Count - 1 do
                        if treeView.Items.item[tv].item[tvs].Text = filho then
                            tem := True;

                    if tem = false then
                        treeView.Items.AddChild(treeView.Items.item[tv].item[tvs], filho);
                end;
        end;
    end;
end;

function TOrcamento.AddTreeViewDeletar(item: TOrcamentoItens; treeView: TTreeView): boolean;
var
    index, i: integer;
    itemOrc: TOrcamentoItens;
    pai, filho: String;
begin
    result := false;
    i := 0;
    while i <= Self.OrcamentoItens.Count - 1 do
    begin
        itemOrc := Self.OrcamentoItens[i];

        if (itemOrc.LocalEstoquePaiAlternativo = item.LocalEstoque) and (itemOrc.ProdutoPaiAlternativo.codigo = item.CodigoProduto) and
            (itemOrc.TipoEntregaPaiAlternativo.tipoEntrega = item.TipoEntrega_.tipoEntrega) then
        begin
            pai := item.CodigoProduto + '-' + item.LocalEstoque + '-' + item.TipoEntrega_.tipoEntrega;
            filho := itemOrc.CodigoProduto + '-' + itemOrc.LocalEstoque + '-' + itemOrc.TipoEntrega_.tipoEntrega;
            AddTreeView(pai, filho, treeView);
            result := True;
            AddTreeViewDeletar(itemOrc, treeView);
        end;

        Inc(i);
    end;
    result := True;
end;

procedure TOrcamento.AdicionarCreditoCliente(credito: TCreditoCliente);
begin
    Self.FCreditosCliente.add(credito);
end;

function TOrcamento.Alterar: integer;
begin
    baseLib.ExecutaTarefa('AlterarOrcamento', 'TOrcamento', ObjetoParaParametros(acAlteracao));
    // ###Validar retorno da função
    result := 0;
end;

procedure TOrcamento.AlterarParcelasDaMesmaCondicaoPagamento(condicaoPgto: TOrcamentoPagamento);
var
    condicao, primeiraCondicao: TOrcamentoPagamento;
    achou: boolean;
    i, j: integer;
    ultimaParcela: integer;
    alteraParcela: boolean;
begin
    if (condicaoPgto.formaPagamento = fpAVista) or (condicaoPgto.formaPagamento = fpCartaoDebito) then
        exit;

    for i := 0 to Self.ObterQuantidadeCondicaoPagamento - 1 do
    begin
        // acha a parcela alterada (passada por parametro)
        if FOrcamentoPagamento[i] = condicaoPgto then
        begin
            // acha a primeira parcela
            for j := i downto 0 do
            begin
                if StrToInt(Self.FOrcamentoPagamento[j].Parcela) = 1 then
                begin
                    primeiraCondicao := Self.FOrcamentoPagamento[j];
                    break;
                end;
            end;
        end;
    end;

    ultimaParcela := 1;
    alteraParcela := True;
    achou := false;

    for i := 0 to Self.ObterQuantidadeCondicaoPagamento - 1 do
    begin

        // acha a primeira parcela
        condicao := Self.FOrcamentoPagamento[i];
        if condicao = primeiraCondicao then
            achou := True;

        if achou then
        begin
            // verifica se esta parcela esta dentro do numero de parcelas da parcela alterada
            if (alteraParcela) then
            begin
                condicao.administradora := condicaoPgto.administradora;
                condicao.tipoCheque := condicaoPgto.tipoCheque;
                condicao.agenciaBanco := condicaoPgto.agenciaBanco;
                condicao.conta := condicaoPgto.conta;
                condicao.NomeCliente := condicaoPgto.NomeCliente;
                condicao.rg := condicaoPgto.rg;
                condicao.cgc := condicaoPgto.cgc;
                condicao.telefone := condicaoPgto.telefone;
                condicao.observacao := condicaoPgto.observacao;
                // condicao.ValorParcelaDedudizo := condicaoPgto.ValorParcelaDedudizo;
                // faz o calculo do valor deduzido pela taxa da administradora
                if condicaoPgto.Administradora_.preenchido then
                begin
                    condicaoPgto.Administradora_.CopiarPara(condicao.Administradora_);
                    condicao.ValorParcelaDedudizo := (condicao.ValorParcela - ((condicao.ValorParcela / 100) * condicao.Administradora_.Taxa));
                end;

                // somente cheque porque pra cada parcela de cheque pq cada cheque tem um número específico,
                /// esse campo guarda o numero do cartao de credito tbm
                if (condicaoPgto.formaPagamento <> fpCheque) then
                    condicao.NumeroDocumento := condicaoPgto.NumeroDocumento;

                condicao.NSUTef := condicaoPgto.NSUTef;
                condicao.NSUHost := condicaoPgto.NSUHost;
                condicao.Autorizacao := condicaoPgto.Autorizacao;

                ultimaParcela := StrToInt(condicao.Parcela);

                // verifico se a próxima parcela pode ser alterada
                alteraParcela := false;
                if i < Self.ObterQuantidadeCondicaoPagamento - 1 then
                    if StrToInt(Self.FOrcamentoPagamento[i + 1].Parcela) <> 1 then
                        alteraParcela := True;

            end
            else
                break;

        end;
    end;
end;

procedure TOrcamento.BloquearOrcamento;
begin
    Self.TipoOrcamento := '3-BLO';
    baseLib.ExecutaTarefa('AlterarStatusOrcamento', 'TOrcamento', ObjetoParaParametros(acAlteracao));

end;

procedure TOrcamento.CancelarCondicaoPagamento(formaPg: TFormaPagamento; administradora, sequenciamentoCartao: string);
var
    index: integer;
begin
    index := 0;
    for index := 0 to Self.OrcamentoPagamento.Count - 1 do
    begin
        if (Self.OrcamentoPagamento[index].formaPagamento = formaPg) and (Self.OrcamentoPagamento[index].administradora = administradora) and
            (Self.OrcamentoPagamento[index].sequenciamentoCartao = sequenciamentoCartao) then
        begin
            Self.OrcamentoPagamento.Delete(index);
            CancelarCondicaoPagamento(formaPg, administradora, sequenciamentoCartao);
            break;
        end;
    end;
end;

function TOrcamento.ConferirProduto(produto: string; quantidade, quantidadeMinima: double): string;
var
    item, itemSelf: TOrcamentoItens;
    quantidadeDigitada: double;
    total: integer;
begin
    if (trim(produto) <> EmptyStr) and (FOrcamentoConferencia <> nil) then
    begin
        item := nil;

        if not Self.ValidarConferencia(produto, item) then
            exit;

        quantidadeDigitada := quantidade;
        if (compareValue(item.quantidade, quantidadeMinima) = GreaterThanValue) and
            ((compareValue(quantidadeDigitada, item.RemanescenteConferencia) = LessThanValue) or
            (compareValue(quantidadeDigitada, item.RemanescenteConferencia) = EqualsValue)) then
        begin
            if not item.produto.ValidarQuantidadeMultipla(quantidadeDigitada, false) then
                quantidadeDigitada := item.produto.ObterQuantidadeMultipla(item.produto.codigo);

            item.QuantidadeConferida := item.QuantidadeConferida + quantidadeDigitada;
        end
        else
        begin
            // if not item.Produto.ValidarQuantidadeMultipla(quantidadeDigitada, false) then
            item.QuantidadeConferida := item.QuantidadeConferida + item.produto.ObterQuantidadeMultipla(item.produto.codigo)
            // else
            // item.QuantidadeConferida := item.QuantidadeConferida + 1;
        end;
        result := item.produto.codigo;


        if (item.Produto.ProdutoSelfColor and item.Conferido) then
            for itemSelf in Self.FOrcamentoConferencia.OrcamentoItens do
            begin
                if itemSelf.ItemPai = item.Item then
                    itemSelf.QuantidadeConferida := itemSelf.Quantidade;
            end;



    end;
end;

function TOrcamento.ConsultarCreditosCliente: boolean;
var
    contasReceberCliente: TLista<TContasReceber>;
    contaReceber: TContasReceber;
    creditoCliente: TCreditoCliente;
    valorRestante: double;
    i: integer;
begin
    result := false;
    if Cliente.VerificarClientePadrao then
        raise Erro.Create('Não é permitido esta forma de pagamento para este cliente!');;

    valorRestante := ObterValorRestanteParaPagamento;

    contasReceberCliente := TContasReceber.ListarCreditoPendente(Self.SequencialCliente, Self.CodigoCliente);

    i := 0;

    for contaReceber in contasReceberCliente do
    begin
        if valorRestante > 0 then
        begin
            Inc(i);

            creditoCliente := TCreditoCliente.Create;

            creditoCliente.Filial := Self.Filial;
            creditoCliente.PrefixoNCC := contaReceber.Prefixo;
            creditoCliente.NumeroNCC := contaReceber.Numero;
            creditoCliente.ParcelaNCC := contaReceber.Parcela;
            creditoCliente.TipoNCC := contaReceber.Tipo;
            creditoCliente.ClienteNCC := contaReceber.CodigoCliente;
            creditoCliente.SequencialNCC := contaReceber.SequencialCliente;
            creditoCliente.FilialNCC := contaReceber.CodigoFilial;
            // creditoCliente.NumeroOrcamento
            if valorRestante > contaReceber.ValorDisponivel then
            begin
                creditoCliente.Valor := contaReceber.ValorDisponivel;
                valorRestante := (valorRestante - contaReceber.ValorDisponivel);
            end
            else
            begin
                creditoCliente.Valor := valorRestante;
                valorRestante := 0;
            end;

            creditoCliente.Status := contaReceber.StatusLiberacaoDeCredito;
            // creditoCliente.Data
            // creditoCliente.Usuario
            // creditoCliente.DataCancelamento
            // creditoCliente.UsuarioCancelamento
            // creditoCliente.MotivoCancelamento
            // creditoCliente.Delete
            // creditoCliente.Recno
            // creditoCliente.SaldoPendenteCompensar
            // creditoCliente.PrefixoOrc
            // creditoCliente.ParcelaOrc
            // creditoCliente.ClienteOrc
            // creditoCliente.SequencialOrc
            // creditoCliente.TipoOrc
            // creditoCliente.DocumentoOrigem
            // creditoCliente.RecnoDaSZ9
            creditoCliente.NomeCliente := contaReceber.NomeCliente;
            creditoCliente.SaldoNCC := contaReceber.SaldoDevedor;
            creditoCliente.ValorReservado := contaReceber.ValorReservado;
            creditoCliente.ValorDisponivel := contaReceber.ValorDisponivel;
            creditoCliente.ValorNCC := contaReceber.Valor;
            creditoCliente.EmissaoNCC := contaReceber.DataEmissao;
            creditoCliente.formaPagamento := 'TDC';
            creditoCliente.Sequenciamento := i;

            AdicionarCreditoCliente(creditoCliente);

            result := True;
        end;
    end;
end;

procedure TOrcamento.CopiarPara(objeto: TObject);
var
    item, novoItem: TOrcamentoItens;
    pagto, novoPagto: TOrcamentoPagamento;
    orc, novoOrc: TOrcamento;
begin
    inherited;

     if Self.Vendedor.Preenchido then
            Self.Vendedor.CopiarPara(TOrcamento(objeto).Vendedor);

    if Self.CopiaCompleta then
    begin
        // Self.OrcamentoItens.CopyTo(TOrcamento(objeto).OrcamentoItens);
        // Self.OrcamentoPagamento.CopyTo(TOrcamento(objeto).OrcamentoPagamento);



        for item in OrcamentoItens do
        begin
            novoItem := TOrcamentoItens.Create;
            item.CopiarPara(novoItem);
            TOrcamento(objeto).AddOrcamentoItem(novoItem);
        end;

        for pagto in OrcamentoPagamento do
        begin
            novoPagto := TOrcamentoPagamento.Create;
            pagto.CopiarPara(novoPagto);
            TOrcamento(objeto).AddOrcamentoPagto(novoPagto);
        end;
    end
    else
        // caso a copia nao seja completa eu zero os totais, já que será uma cópia somente do cabeçalho do orcamento;
        TOrcamento(objeto).ZerarTotais;

end;

constructor TOrcamento.Create;
begin
    Self.Create(tvVendaBalcao)
end;

procedure TOrcamento.ZerarPrecoEmTabela;
var
    item: TOrcamentoItens;
begin
    for item in OrcamentoItens do
    begin
        item.ValorUnitario := item.PrecoTabela;
    end;
end;

function TOrcamento.ZerarRateioValoresNosItens(nomeCampoParaRateio: String): boolean;
var
    item: TOrcamentoItens;
begin
    try
        for item in Self.OrcamentoItens do
            item.SetarValorPorNomePropriedade(nomeCampoParaRateio, '0');
    finally

    end;
end;

procedure TOrcamento.ZerarTotais;
begin
    Self.FValorDespesa := 0;
    Self.FValorSeguro := 0;
    Self.FValorFrete := 0;
    Self.FValorIcms := 0;
    Self.FValorBruto := 0;
    Self.FValorDesconto := 0;
    Self.FValorSubstituicao := 0;
    Self.FValorMercadoria := 0;
    Self.FValorPromocao := 0;

    Self.FPesoBruto := 0;
    Self.FPesoLiquido := 0;

    Self.FValorDescontoTotalNegociado := 0;
    Self.FValorAcrescimosTotalNegociado := 0;
end;

constructor TOrcamento.Create(tipoVda: TTipoVenda);
begin
    FOrcamentoItens := TLista<TOrcamentoItens>.Create;
    FOrcamentoPagamento := TLista<TOrcamentoPagamento>.Create;
    FCreditosCliente := TLista<TCreditoCliente>.Create;
    FVendedor := TVendedor.Create;
    FCliente := TCliente.Create;

    // como padrão colocamos a filial do usuário logado
    FFilial_ := TFilial.Create;
    TUsuarioLogado.ObterInstancia.Filial.CopiarPara(Self.Filial_);
    Self.Filial_.ObterListaTipoEntrega(tipoVda);

    CopiaCompleta := True;
    Self.TipoVenda := tipoVda;
end;

function TOrcamento.Deletar(ID: string): integer;
var
    parametro: TParametro;
begin
    try
        parametro := TParametro.Create;
        parametro.add('', 'R_E_C_N_O_', ID);

        baseLib.ExecutaTarefa('DeletarOrcamento', 'TOrcamento', parametro);

        // ###Validar retorno da função
        result := 0;
    finally
        parametro.Free;
    end;
end;

function TOrcamento.DeletarOrcamentoItem(item: TOrcamentoItens; mostraMensagem: boolean): boolean;
var
    index, i: integer;
    itemOrc: TOrcamentoItens;
    deletarFilhos: boolean;
begin
    result := false;
    deletarFilhos := True;
    i := 0;

    if (mostraMensagem) then
    begin
        Self.MostrarArvoreProdutosAlternativos(item);

        if (Tlib.MensagemPergunta('Confirma a exclusão dos itens filhos?', 'Confirmação') = mrNo) then
            deletarFilhos := false;
    end;

    if deletarFilhos then
    begin
        while i <= Self.OrcamentoItens.Count - 1 do
        begin
            itemOrc := Self.OrcamentoItens[i];

            if (itemOrc.LocalEstoquePaiAlternativo = item.LocalEstoque) and (itemOrc.ProdutoPaiAlternativo.codigo = item.CodigoProduto) and
                (itemOrc.TipoEntregaPaiAlternativo.tipoEntrega = item.TipoEntrega_.tipoEntrega) then
            begin
                if Self.DeletarOrcamentoItem(itemOrc) then
                begin
                    i := 0;
                    continue;
                end;
            end;

            Inc(i);
        end;
    end
    else
        Self.AtualizarFilhosCrossSelling(nil, item);

    index := Self.OrcamentoItens.IndexOf(item);
    Self.OrcamentoItens.Delete(index);

    result := True;

    // reorganiza os itens
    i := 1;
    for itemOrc in Self.OrcamentoItens do
    begin
        itemOrc.item := Tlib.ColocarZeroEsquerda(2, inttostr(i));
        Inc(i);
    end;
end;

procedure TOrcamento.DesmembrarOrcamento;

    function ObterDiferencaCondicaoPgtoFilhosComCondicaoPagtoMae(condicaoPgto: TOrcamentoPagamento): double;
    var
        orc: TOrcamento;
        totalCondicao: double;
    begin
        totalCondicao := 0;
        for orc in Self.OrcamentosFilhos do
            totalCondicao := totalCondicao + orc.ObterValorTotalCondicaoPagamento(condicaoPgto);

        result := Self.ObterValorTotalCondicaoPagamento(condicaoPgto) - totalCondicao;
    end;

var
    orc, novoOrcamento: TOrcamento;
    item, novoItem: TOrcamentoItens;
    orcPagto, novoOrcPagto: TOrcamentoPagamento;

    tpEntrega, novoTipoEntrega: TTipoEntrega;

    encontrou: boolean;
    valorRateadoCondicaoPgto, valorTotalCondicaoPgto: double;
    Parcela, totalParcelaCondicao: integer;
    valorDiferenca: double;
    dataAtual: string;

    hi, hf: TDateTime;
begin
    // hi := Now;
    if FOrcamentosFilhos <> nil then
        FreeAndNil(FOrcamentosFilhos);

    dataAtual := Tlib.ObterDataAtual;

    FOrcamentosFilhos := TLista<TOrcamento>.Create;
    encontrou := True;

    try
        Self.Filial_.ObterListaTipoEntrega;
        if Self.Filial_.TiposEntrega <> nil then
        begin
            for tpEntrega in Self.Filial_.TiposEntrega do
            begin
                if encontrou then
                begin
                    novoOrcamento := TOrcamento.Create;
                    Self.CopiaCompleta := false;
                    Self.CopiarPara(novoOrcamento);
                end;

                encontrou := false;
                for item in Self.OrcamentoItens do
                begin
                    // Não pode ser DL, por que DL e LJ são entregues no mesmo lugar, então é valdiado no if abaixo;
                    if tpEntrega.tipoEntrega <> 'DL' then
                    begin
                        if (item.tipoEntrega = tpEntrega.tipoEntrega) or ((tpEntrega.tipoEntrega = 'LJ') and (item.tipoEntrega = 'DL')) then
                        begin

                            // Como venda futura tbm é marcada como CD é preciso fazer essa validacao
                            if (item.tipoEntrega = 'CD') and ((Self.TipoVenda <> tvVendaFutura) and (tpEntrega.TipoOrcamento = '6-FUT') or
                                (Self.TipoVenda = tvVendaFutura) and (tpEntrega.TipoOrcamento = '9-ENT')) then
                                continue;

                            //
                            if tpEntrega.TipoOrcamento = '6-FUT' then
                                novoOrcamento.OperacaoVenda := 'O'
                            else if tpEntrega.TipoOrcamento = '8-EOK' then
                            begin
                                novoOrcamento.OperacaoVenda := 'F';
                                novoOrcamento.Tipo := 'V';
                            end
                            else
                                novoOrcamento.OperacaoVenda := 'R';

                            //
                            if StrToIntDef(tpEntrega.tipoEntrega, 0) = 0 then
                            begin
                                if tpEntrega.LocalEntrega = 'CD' then
                                    //novoOrcamento.Filial := TUsuarioLogado.ObterInstancia.Filial.CD
                                else
                                    //novoOrcamento.Filial := TUsuarioLogado.ObterInstancia.Filial;
                            end
                            else
                                novoOrcamento.Filial := tpEntrega.tipoEntrega;

                            //
                            if (tpEntrega.TipoOrcamento = '6-FUT') or (tpEntrega.TipoOrcamento = '9-ENT') or (tpEntrega.TipoOrcamento = '9-ENL') then
                                Self.ControleEntrega := 'S';
                            //

                            novoItem := TOrcamentoItens.Create;
                            item.CopiarPara(novoItem);

                            novoTipoEntrega := TTipoEntrega.Create;
                            tpEntrega.CopiarPara(novoTipoEntrega);
                            novoItem.TipoEntrega_ := novoTipoEntrega;
                            novoItem.Filial := novoOrcamento.Filial;
                            // Obtem o numero do item do orcamento
                            novoItem.item := Tlib.ColocarZeroEsquerda(2, inttostr(novoOrcamento.ObterQuantidadeItens + 1));
                            novoItem.itemOrigem := item.item;

                            // Validações Item
                            if tpEntrega.TipoOrcamento <> '8-EOK' then
                                novoItem.CodigoPDV := EmptyStr
                            else
                            begin
                                novoItem.Vendido := 'S';
                                novoItem.CodigoPDV := Self.CodigoPDV;
                            end;

                            novoOrcamento.AddOrcamentoItem(novoItem);
                            encontrou := True;
                        end;
                    end;
                end;

                if encontrou then
                begin
                    novoOrcamento.TipoOrcamento := tpEntrega.TipoOrcamento;

                    novoOrcamento.PesoLiquido := novoOrcamento.ObterPesoTotalItens;
                    novoOrcamento.PesoBruto := novoOrcamento.PesoLiquido;
                    novoOrcamento.SenhaAutorizador := '';

                    if novoOrcamento.TipoOrcamento = '9-PSE' then
                        novoOrcamento.TipoDaVenda := 'PE'
                    else
                        novoOrcamento.TipoDaVenda := 'OD'; // aparentemente orcamento desmembrado

                    if novoOrcamento.TipoOrcamento = '8-EOK' then
                        novoOrcamento.DataEmissaoDocumento := dataAtual;

                    // alimento a origem do orcamento
                    novoOrcamento.NumeroOrcamentoOrigem := Self.Filial + Self.Numero;

                    Self.OrcamentosFilhos.add(novoOrcamento);

                    // totaliza totais especificamente somando os itens do orcamento
                    novoOrcamento.ObterTotaisOrcamento;
                end;
            end;

            // Caso não tenha encontrado no ultimo loop eu apago para não dar leak de memoria
            if not encontrou then
                FreeAndNil(novoOrcamento);

            // Rateio o valor das parcelas nos orcamentos filhos.
            if Self.OrcamentosFilhos.Count > 0 then
            begin
                for orc in Self.OrcamentosFilhos do
                begin
                    Parcela := 0;
                    for orcPagto in Self.OrcamentoPagamento do
                    begin
                        // contador das parcelas
                        Parcela := Parcela + 1;

                        // obtem o total de parcelas para cada condição de pagamento
                        if Parcela = 1 then
                            totalParcelaCondicao := Self.ObterTotalParcelas(orcPagto);

                        novoOrcPagto := TOrcamentoPagamento.Create;
                        orcPagto.CopiarPara(novoOrcPagto);

                        // acha o valor da parcela e o valor total da condição de pagamento
                        if Parcela = 1 then
                        begin
                            // total da condição do orcamento mae
                            valorTotalCondicaoPgto := Self.ObterValorTotalCondicaoPagamento(orcPagto);
                            // faço a proporção com o orcamento mae
                            valorTotalCondicaoPgto := RoundTo((valorTotalCondicaoPgto * orc.ValorLiquido) / Self.ValorLiquido, -2);
                            valorRateadoCondicaoPgto := RoundTo(valorTotalCondicaoPgto / totalParcelaCondicao, -2);
                        end;

                        // Faço o ajuste na última parcela da condição de pgamento caso haja diferença
                        if Parcela = totalParcelaCondicao then
                        begin
                            novoOrcPagto.ValorParcela := valorRateadoCondicaoPgto +
                                (valorTotalCondicaoPgto - (valorRateadoCondicaoPgto * totalParcelaCondicao));
                            Parcela := 0;
                            totalParcelaCondicao := 0;
                        end
                        else
                            novoOrcPagto.ValorParcela := valorRateadoCondicaoPgto;

                        novoOrcPagto.Filial := orc.Filial;

                        orc.AddOrcamentoPagto(novoOrcPagto);

                        // totaliza totais especificamente das condições de pagamento
                        orc.ObterTotaisOrcamento;

                        // Obtenho o numero do orcamento aqui, pois aqui eu tenho os itens e condição de pagamento.
                        orc.ObterNumeroOrcamento;
                    end;
                end;

                // Para garantir integridade dos valores, valido a diferença de valores nos totais, ou seja,
                // verifico se existe diferença no total orcamento com o total das confiçãoes de pagamento
                // caso haja tal diferença, eu verifico a somatória dos totais de cada condição de pagamento com o total da condição de pagamento do orcamento mãe
                // e em caso de diferença faço o ajuste, distribuindo essa diferença
                for orc in Self.OrcamentosFilhos do
                begin
                    // diferença do total do orcamento com o total das condições de pagamento
                    if not compareValue(orc.ValorLiquido, orc.ObterValorTotalTodasCondicoesPagamento) = EqualsValue then
                    begin
                        for orcPagto in orc.OrcamentoPagamento do
                        begin
                            valorDiferenca := ObterDiferencaCondicaoPgtoFilhosComCondicaoPagtoMae(orcPagto);

                            if valorDiferenca <> 0 then
                                orcPagto.ValorParcela := orcPagto.ValorParcela + valorDiferenca;

                        end;
                    end;
                end;
            end;
        end;
        // hf := now;
        // showmessage(FormatDateTime('hh:mm:ss',hf-hi));
    finally

    end;
end;

destructor TOrcamento.Destroy;
begin
    if FOrcamentoItens <> nil then
        FreeAndNil(FOrcamentoItens);

    if FOrcamentoPagamento <> nil then
        FreeAndNil(FOrcamentoPagamento);

    if FVendedor <> nil then
        FreeAndNil(FVendedor);

    if FCliente <> nil then
        FreeAndNil(FCliente);

    if FFilial_ <> nil then
        FreeAndNil(FFilial_);

    if FOrcamentoConferencia <> nil then
        FreeAndNil(FOrcamentoConferencia);

    if FCreditosCliente <> nil then
        FreeAndNil(FCreditosCliente);

    inherited;
end;

function TOrcamento.GerarParcelas(formaPagamento_GP: TFormaPagamento; administradora_GP: TAdministradora; valorTotal_GP: double;
    quantidadeParcelas_GP: integer; primeiraDataVcto_GP: string; tipoGeracaoParcela_GP: TTipoGeracaoParcela; dias_GP, intervalo_GP: integer;
    tipoCheque_GP, agenciaBanco_GP, conta_GP, numeroDocumento_GP, nomeCliente_GP, rg_GP, cgc_GP, telefone_GP, observacao_GP: string): boolean;
var
    // i: integer;
    condicaoPgto: TOrcamentoPagamento;
    ValorParcela: double;
    /// /    OrcamentoPagamento: TOrcamentoPagamento;
    administradoraDescricao: string;
    // quantidadeZeros: integer;
    ultimaSequenciaCartao: integer;
    temDP, temOutrasFormasDepagamento: boolean;
begin
    result := True;

    ultimaSequenciaCartao := 0;

    if administradora_GP = nil then
        administradoraDescricao := ''
    else
        administradoraDescricao := administradora_GP.Descricao;

    { Verifica quantidade maxima por forma de pagamento }
    if (administradora_GP <> nil) and (administradora_GP.QuantidadeParcelasMaxima < quantidadeParcelas_GP) then
    begin
        Tlib.MensagemErro('Erro ao gerar condição de pagamento', 'Não é possível gerar parcelas maior que ' +
            inttostr(administradora_GP.QuantidadeParcelasMaxima) + 'x ', 'Erro');
        result := false;
        exit;
    end;

    { Verifica se foi selecionado uma tabela de comissão, e se a quantidade de parcelas é igual a quantidade seleniona na tabela de comissão }
    if (Self.TabelaComissao <> nil) and (Self.TabelaComissao.CodigoTabela <> 'T1') then
    begin
        if ((Self.TabelaComissaoQuantidadeParcelas - Self.ObterQuantidadeCondicaoPagamento) <> quantidadeParcelas_GP) then
        begin
            Tlib.MensagemErro('Erro ao gerar condição de pagamento', 'Não é possível gerar parcelas diferente a ' +
                inttostr((Self.TabelaComissaoQuantidadeParcelas - Self.ObterQuantidadeCondicaoPagamento)) + 'x ', 'Erro');
            result := false;
            exit;
        end;
    end;

    // Verifica se pode gerar mais parcelas.
    if Self.ObterValorTotalTodasCondicoesPagamento >= Self.ValorLiquido then
    begin
        Tlib.MensagemErro('Erro ao gerar condição de pagamento', 'Não é possível mais gerar condições de pagamento', 'Erro');
        result := false;
        exit;
    end;

    // Valida data primeiro vencimento
    if primeiraDataVcto_GP = EmptyStr then
    begin
        Tlib.MensagemAdvertencia('Data do Primeiro vencimento obrigatório.', 'Aviso');
        result := false;
        exit;
    end;

    // valida valores obrigatorios para cheque
    if formaPagamento_GP = fpCheque then
    begin
        if (tipoCheque_GP = EmptyStr) or (agenciaBanco_GP = EmptyStr) or (conta_GP = EmptyStr) then
        begin
            Tlib.MensagemAdvertencia('Informações dos cheques são obrigatórias.', 'Aviso');
            result := false;
            exit;
        end;
    end;

    // Valida Condições extras para cliente padrão.
    if (formaPagamento_GP = fpDuplicata) or (formaPagamento_GP = fpCheque) or (formaPagamento_GP = fpFinanciamento) then
    begin
        if Self.CodigoCliente = Self.Cliente.CodigoClientePadrao then
        begin
            Tlib.MensagemAdvertencia('Não é permitido a geração de venda com cheque, duplicata ou financiado para consumidor final.', 'Aviso');
            result := false;
            exit;
        end;
    end;

    // Verifica se ja existe a condição de pagamento
    // Condições que só podem ser incluidas uma vez
    if (formaPagamento_GP in [fpAVista, fpFinanciamento, fpDuplicata, fpCompesacaoCreditoTDC, fpExclusivoTDE, fpPrivativoTDP]) then
    begin
        for condicaoPgto in Self.OrcamentoPagamento do
        begin
            if condicaoPgto.formaPagamento = formaPagamento_GP then
            begin
                Tlib.MensagemAdvertencia('Forma existe esta forma de pagamento.', 'Aviso');
                result := false;
                exit;
            end;
        end;
    end
    // Condições que podem ser incluidas mais de uma vez
    else if (formaPagamento_GP <> fpCheque) then
    begin
        // Verifca se tem todas as administradora ou banco e as inclui
        for condicaoPgto in Self.OrcamentoPagamento do
        begin
            if not(condicaoPgto.formaPagamento in [fpCartaoCredito, fpCartaoDebito]) then
            begin
                if (condicaoPgto.formaPagamento = formaPagamento_GP) and (condicaoPgto.administradora = administradoraDescricao) then
                begin
                    Tlib.MensagemAdvertencia('Administradora ou banco existente para esta forma de pagamento!!!', 'Aviso');
                    result := false;
                    exit;
                end;
            end
            else
                ultimaSequenciaCartao := StrToIntDef(condicaoPgto.sequenciamentoCartao, 0);
        end;
    end;

    ValorParcela := RoundTo((ValorTotal / quantidadeParcelas_GP), -2);

    if formaPagamento_GP <> fpCompesacaoCreditoTDC then
    begin
        if not GerarParcelasOutros(quantidadeParcelas_GP, dias_GP, intervalo_GP, ultimaSequenciaCartao, tipoGeracaoParcela_GP, formaPagamento_GP,
            primeiraDataVcto_GP, administradoraDescricao, tipoCheque_GP, agenciaBanco_GP, conta_GP, rg_GP, cgc_GP, telefone_GP, observacao_GP,
            NumeroDocumento, NomeCliente, ValorParcela, valorTotal_GP) then
        begin
            result := false;
            exit;
        end;
    end
    else
    begin
        if not GerarParcelasTDC(primeiraDataVcto_GP, administradoraDescricao, formaPagamento_GP) then
        begin
            result := false;
            exit;
        end;
    end;

    { Forma de pagamento em Duplicata DP, não é permitido informar outras formas de pagamento,
      com exceção de TDC }
    temDP := false;
    temOutrasFormasDepagamento := false;
    for condicaoPgto in Self.OrcamentoPagamento do
    begin
        if condicaoPgto.FormaPagamento_ = 'DP' then
            temDP := True
        else if condicaoPgto.FormaPagamento_ <> 'TDC' then
            temOutrasFormasDepagamento := True;
    end;
    if (temDP) and (temOutrasFormasDepagamento) then
    begin
        result := false;
        Self.LimparCondicoesPagamento;
        Tlib.MensagemInformacao('Não é permitido duplicata com outras formas de pagamento');
        exit;
    end;
end;

function TOrcamento.GerarParcelas(formaPagamento_GP: TFormaPagamento; administradora_GP: TAdministradora; valorTotal_GP: double;
    quantidadeParcelas_GP: integer; primeiraDataVcto_GP: string; tipoGeracaoParcela_GP: TTipoGeracaoParcela; dias_GP, intervalo_GP: integer): boolean;
begin
    result := Self.GerarParcelas(formaPagamento_GP, administradora_GP, valorTotal_GP, quantidadeParcelas_GP, primeiraDataVcto_GP,
        tipoGeracaoParcela_GP, dias_GP, intervalo_GP, EmptyStr, EmptyStr, EmptyStr, EmptyStr, EmptyStr, EmptyStr, EmptyStr, EmptyStr, EmptyStr);
end;

function TOrcamento.GerarParcelasOutros(quantidadeParcelas_GP, dias_GP, intervalo_GP, ultimaSequenciaCartao_GP: integer;
    tipoGeracaoParcela_GP: TTipoGeracaoParcela; formaPagamento_GP: TFormaPagamento; primeiraDataVcto_GP, administradoraDescricao_GP, tipoCheque_GP,
    agenciaBanco_GP, conta_GP, rg_GP, cgc_GP, telefone_GP, observacao_GP, numeroDocumento_GP, nomeCliente_GP: String;
    valorParcela_GP, valorTotalRestante_GP: double): boolean;
var
    i, tamanhoNumeroDocumento, doc: integer;
    OrcamentoPagamento: TOrcamentoPagamento;
    documento, dataPagamento: string;
begin
    result := false;
    dataPagamento := primeiraDataVcto_GP;

    for i := 1 to quantidadeParcelas_GP do
    begin
        if quantidadeParcelas_GP > 1 then
        begin
            // Valida data pagamento
            if i > 1 then
            begin
                dias_GP := Tlib.IfTernario((tipoGeracaoParcela_GP = tgIntervalo) and (formaPagamento_GP = fpCheque), intervalo_GP, dias_GP);

                dataPagamento := DateToStr(Tlib.IncrementaData(dataPagamento, dias_GP));

                // Verifica se o mes incrementado é igual ao mes anterior, se for incremente mais 1 dia
                if MonthOf(StrToDate(primeiraDataVcto_GP)) = MonthOf(StrToDate(dataPagamento)) then
                    dataPagamento := DateToStr(Tlib.IncrementaData(dataPagamento, 1));
            end;

            // Valida se é por vencimento  ou intervalo
            if tipoGeracaoParcela_GP <> tgNenhum then
            begin

                // Coloca o dia do vencimento no dia desejado
                dataPagamento := Tlib.ColocarZeroEsquerda(2, inttostr(intervalo_GP)) + copy(dataPagamento, 3, 8);

                // Decrementa Data
                while not Tlib.ValidaData(dataPagamento) do
                begin
                    dataPagamento := Tlib.ColocarZeroEsquerda(2, inttostr(intervalo_GP - 1)) + copy(dataPagamento, 3, 8);
                end;
            end;

            // Valida arredondamento das parcelas
            if i = quantidadeParcelas_GP then
                valorParcela_GP := valorParcela_GP + (valorTotalRestante_GP - (valorParcela_GP * quantidadeParcelas_GP));

        end
        else
        begin
            valorParcela_GP := valorTotalRestante_GP;
            dataPagamento := primeiraDataVcto_GP;
        end;

        OrcamentoPagamento := TOrcamentoPagamento.Create;

        OrcamentoPagamento.FormaPagamento_ := TOrcamentoPagamento.FormaPagamentoParaString(formaPagamento_GP);
        OrcamentoPagamento.administradora := administradoraDescricao_GP;
        OrcamentoPagamento.Vencimento := FormatDateTime('yyyymmdd', StrToDate(dataPagamento));
        OrcamentoPagamento.ValorParcela := valorParcela_GP;
        OrcamentoPagamento.Numero := ''; // TOrcamentoPagamento.ObtemValorParcela(i - 1);
        OrcamentoPagamento.tipoCheque := tipoCheque_GP;
        OrcamentoPagamento.agenciaBanco := agenciaBanco_GP;
        OrcamentoPagamento.conta := conta_GP;

        // incrementa o numero do documento
        if NumeroDocumento <> EmptyStr then
        begin
            if i > 1 then
            begin
                tamanhoNumeroDocumento := Length(documento);
                doc := StrToInt(NumeroDocumento);
                Inc(doc);
                NumeroDocumento := inttostr(doc);
                documento := Tlib.ColocarZeroEsquerda(tamanhoNumeroDocumento, NumeroDocumento);
            end
            else
                documento := NumeroDocumento;
        end;
        OrcamentoPagamento.Filial := TUsuarioLogado.ObterInstancia.Filial.Filial;
        OrcamentoPagamento.NumeroDocumento := documento;
        OrcamentoPagamento.NomeCliente := NomeCliente;
        OrcamentoPagamento.rg := rg_GP;
        OrcamentoPagamento.cgc := cgc_GP;
        OrcamentoPagamento.telefone := telefone_GP;
        OrcamentoPagamento.observacao := observacao_GP;
        OrcamentoPagamento.Parcela := Tlib.ColocarZeroEsquerda(3, inttostr(i));
        OrcamentoPagamento.sequenciamentoCartao := Tlib.IfTernario(formaPagamento_GP in [fpCartaoDebito, fpCartaoCredito],
            inttostr(ultimaSequenciaCartao_GP + 1), EmptyStr);
        OrcamentoPagamento.Usuario := TUsuarioLogado.ObterInstancia.Login;
        Self.OrcamentoPagamento.add(OrcamentoPagamento);
        result := True;
    end;
end;

function TOrcamento.GerarParcelasTDC(primeiraDataVcto_GP, administradoraDescricao_GP: string; formaPagamento_GP: TFormaPagamento): boolean;
var
    credito: TCreditoCliente;
    dataPagamento: String;
    OrcamentoPagamento: TOrcamentoPagamento;
    i: integer;
begin
    result := false;
    dataPagamento := primeiraDataVcto_GP;

    if CreditosCliente = nil then
    begin
        Tlib.MensagemInformacao('Nenhuma TDC - compensação foi selecionada!');
        exit;
    end;

    i := 0;
    for credito in CreditosCliente do
    begin
        Inc(i);

        OrcamentoPagamento := TOrcamentoPagamento.Create;

        OrcamentoPagamento.FormaPagamento_ := TOrcamentoPagamento.FormaPagamentoParaString(formaPagamento_GP);
        OrcamentoPagamento.administradora := administradoraDescricao_GP;
        OrcamentoPagamento.Vencimento := FormatDateTime('yyyymmdd', StrToDate(dataPagamento));
        OrcamentoPagamento.ValorParcela := credito.Valor;
        OrcamentoPagamento.Numero := ''; // TOrcamentoPagamento.ObtemValorParcela(i - 1);
        OrcamentoPagamento.tipoCheque := '';
        OrcamentoPagamento.agenciaBanco := '';
        OrcamentoPagamento.conta := '';
        OrcamentoPagamento.Filial := TUsuarioLogado.ObterInstancia.Filial.Filial;
        OrcamentoPagamento.NumeroDocumento := '';
        OrcamentoPagamento.NomeCliente := '';
        OrcamentoPagamento.rg := '';
        OrcamentoPagamento.cgc := '';
        OrcamentoPagamento.telefone := '';
        OrcamentoPagamento.observacao := '';
        OrcamentoPagamento.Parcela := Tlib.ColocarZeroEsquerda(3, inttostr(i));
        OrcamentoPagamento.sequenciamentoCartao := inttostr(credito.Sequenciamento);;
        OrcamentoPagamento.Usuario := TUsuarioLogado.ObterInstancia.Login;
        Self.OrcamentoPagamento.add(OrcamentoPagamento);

    end;
    result := True;
end;

function TOrcamento.GetCupomOuNotaFiscal: string;
begin
    result := Tlib.IfTernario((Self.TipoNotaFiscalMicrossiga = EmptyStr) or (Self.TipoNotaFiscalMicrossiga = '4'), 'C', 'N');
end;

function TOrcamento.GetOrcamentoComPrecoNegociado: boolean;
var
    item: TOrcamentoItens;
begin
    result := false;
    for item in OrcamentoItens do
    begin
        if (item.ValorUnitario <> item.PrecoTabela) then
        begin
            result := True;
            break;
        end;
    end;

end;

function TOrcamento.GetOrcamentoComProdutoSelf: boolean;
var
    item: TOrcamentoItens;
begin
    result := false;
    for item in OrcamentoItens do
    begin
        if (item.FormulaSelfColor <> EmptyStr) then
        begin
            result := True;
            break;
        end;
    end;
end;

function TOrcamento.GetOrcamentoComTabela: boolean;
var
    item: TOrcamentoItens;
begin
    result := false;
    for item in OrcamentoItens do
    begin
        if item.Tabela <> EmptyStr then
            if (item.Tabela <> 'T1') and (item.Tabela <> 'T3') then
            begin
                result := True;
                break;
            end;
    end;
end;

function TOrcamento.GetStatusConferencia: TStatusConferencia;
begin
    // em caso de não houve itens para conferir tbm é marcado como conferido
    if Self.ObterQuantidadeItensConferencia = 0 then
        result := Conferido
    else
    begin
        if Self.ObterTotalItensConferidos = 0 then
            result := Aguardando
        else
        begin
            if Self.ObterQuantidadeItensConferencia = Self.ObterTotalItensConferidos then
                result := Conferido
            else
                result := Conferindo
        end;
    end;
end;

function TOrcamento.GetTipoDesconto: string;
begin
    if FTipoDesconto = EmptyStr then
        if Self.ValorDesconto > 0 then
            FTipoDesconto := '1'
        else
            FTipoDesconto := '';
    result := FTipoDesconto;
end;

function TOrcamento.GetTipoEntregaPadrao: TTipoEntrega;
begin
    if FTipoEntregaPadrao = nil then
    begin
        if Self.Filial_.TiposEntrega.Count = 0 then
            Self.Filial_.ObterListaTipoEntrega(Self.TipoVenda);

        FTipoEntregaPadrao := Self.Filial_.ObterTipoEntrega('LJ');
        if FTipoEntregaPadrao = nil then
            FTipoEntregaPadrao := Self.Filial_.ObterTipoEntrega('DL');
        if FTipoEntregaPadrao = nil then
            FTipoEntregaPadrao := Self.Filial_.ObterTipoEntrega('CD');

    end;

    result := FTipoEntregaPadrao;
end;

function TOrcamento.GetTipoVenda: TTipoVenda;
begin
    if TipoDaVenda = 'VR' then
        FTipoVenda := tvVendaRapida
    else if TipoDaVenda = 'VN' then
        FTipoVenda := tvVendaBalcao
    else if TipoDaVenda = 'VF' then
        FTipoVenda := tvVendaFutura
    else
        FTipoVenda := tvOutrosTipos;

    result := FTipoVenda;
end;

function TOrcamento.GetValorBruto: double;
begin
    // if FValorBruto = 0 then
    // ObterTotaisOrcamento;

    result := FValorBruto
end;

function TOrcamento.GetValorDesconto: double;
begin
    // if FValorDesconto = 0 then
    // ObterTotaisOrcamento;

    result := FValorDesconto
end;

function TOrcamento.GetValorDespesa: double;
begin
    // if FValorDespesa = 0 then
    // ObterTotaisOrcamento;

    result := FValorDespesa;
end;

function TOrcamento.GetValorFrete: double;
begin
    // if FValorFrete = 0 then
    // ObterTotaisOrcamento;

    result := FValorFrete;
end;

function TOrcamento.GetValorIcms: double;
begin
    // if FValorIcms = 0 then
    // ObterTotaisOrcamento;

    result := FValorIcms;
end;

function TOrcamento.GetValorIpi: double;
begin
    // if FValorIpi = 0 then
    // ObterTotaisOrcamento;

    result := FValorIpi;
end;

function TOrcamento.GetValorLiquido: double;
begin
    // if FValorLiquido = 0 then
    // ObterTotaisOrcamento;

    result := FValorLiquido;
end;

function TOrcamento.GetValorMercadoria: double;
begin
    result := FValorMercadoria;
end;

function TOrcamento.GetValorSeguro: double;
begin
    if FValorSeguro = 0 then
        // ObterTotaisOrcamento;

        result := FValorSeguro;
end;

function TOrcamento.GetValorSubstituicao: double;
begin
    // if FValorSubstituicao = 0 then
    // ObterTotaisOrcamento;

    result := FValorSubstituicao;
end;

function TOrcamento.GetValorTotal: double;
begin
    // result := 0;
    // if FValorTotal = 0 then
    // ObterTotaisOrcamento;

    result := FValorTotal;
end;

function TOrcamento.GetVersaoSistema: string;
begin
    if trim(FVersaoSistema) = EmptyStr then
        FVersaoSistema := Tlib.ObterVersao;

    result := FVersaoSistema;
end;

procedure TOrcamento.GravarItensConferidos;
var
    arq, orc: string;
    item: TOrcamentoItens;
    arquivo: TextFile;
begin
    try
        try
            if Self.ObterTotalItensConferidos > 0 then
            begin
                arq := ExtractFilePath(Application.ExeName) + 'ORCCONF.txt';
                AssignFile(arquivo, arq);
                Rewrite(arquivo);
                WriteLn(arquivo, Self.Numero);

                for item in Self.FOrcamentoConferencia.OrcamentoItens do
                    WriteLn(arquivo, item.CodigoProduto + '|' + floattostr(item.QuantidadeConferida));

                closefile(arquivo);
            end;
        except
            Tlib.MensagemAdvertencia('Falha ao tentar gravar o arquivo com o itens conferidos.', 'Aviso');
        end;
    finally

    end;
end;

procedure TOrcamento.LiberarOrcamento;
begin
    Self.TipoOrcamento := '1-LIB';
    baseLib.ExecutaTarefa('AlterarStatusOrcamento', 'TOrcamento', ObjetoParaParametros(acAlteracao));
end;

procedure TOrcamento.LimparCondicoesPagamento;
begin
    FreeAndNil(FOrcamentoPagamento);
    FOrcamentoPagamento := TLista<TOrcamentoPagamento>.Create;

    FreeAndNil(FCreditosCliente);
    FCreditosCliente := TLista<TCreditoCliente>.Create;
    // self.OrcamentoPagamento.Clear;
end;

procedure TOrcamento.LimparItensDoOrcamento;
begin
    FreeAndNil(FOrcamentoItens);
    FOrcamentoItens := TLista<TOrcamentoItens>.Create;
    Self.ZerarTotais;
    // self.ObterTotaisOrcamento;
end;

function TOrcamento.Listar(tipoOperacao: TOparationTypes; multiSelect: boolean): TResultFilter;
begin
    result := Self.Listar(tipoOperacao, multiSelect, nil);
end;

procedure TOrcamento.MostrarArvoreProdutosAlternativos(item: TOrcamentoItens);
begin
    frmArvoreProdutosAlternativos := TfrmArvoreProdutosAlternativos.Create(Application.MainForm);

    if item = nil then
        frmArvoreProdutosAlternativos.lbTitulo.Caption := 'Árvore Cross Selling'
    else
        frmArvoreProdutosAlternativos.lbTitulo.Caption := 'Produto ' + item.produto.Descricao + ' tem Cross Selling';

    ObterArvoreProdutosCrossSelling(item, frmArvoreProdutosAlternativos.TreeView1);
    frmArvoreProdutosAlternativos.ShowModal;
    FreeAndNil(frmArvoreProdutosAlternativos);
end;

function TOrcamento.Listar(tipoOperacao: TOparationTypes; multiSelect: boolean; paramentro: TParametro): TResultFilter;
var
    campoFiltro: TFieldFilter;
    filtro: TFilter<TOrcamento>;
    // parametro : TParametro;
    // lista:TLista<TOrcamento>
begin
    inherited;
    try
        filtro := TFilter<TOrcamento>.Create;
        filtro.ScreenName := 'Filtro de Orcamento';
        filtro.OperationType := tipoOperacao;
        filtro.multiSelect := multiSelect;
        filtro.FilterType := ftWithParameters;
        filtro.Task := 'ConsultarOrcamento';
        filtro.AddIndex(1, 'DataEmissao=Z3_EMISSAO,NomeCliente=Z3_TDNOMCL', 'Emissão + Nome do Cliente');
        filtro.AddIndex(1, 'Numero=Z3_NUM', 'Numero Orçamento');
        filtro.parametro := paramentro;

{$REGION 'Campos de Filtro'}
        campoFiltro := TFieldFilter.Create;
        campoFiltro.Description := 'Filial ';
        campoFiltro.Name := 'Filial ';
        campoFiltro.MaskTypes := mtNone;
        campoFiltro.FieldType := fdNormal;
        filtro.AddField(campoFiltro);

        campoFiltro := TFieldFilter.Create;
        campoFiltro.Description := 'Numero';
        campoFiltro.Name := 'Numero';
        campoFiltro.MaskTypes := mtNone;
        campoFiltro.GridSize := 100;
        campoFiltro.FieldType := fdNormal;
        filtro.AddField(campoFiltro);

        campoFiltro := TFieldFilter.Create;
        campoFiltro.Description := 'Código Vendedor';
        campoFiltro.Name := 'CodigoVendedor';
        campoFiltro.MaskTypes := mtNone;
        campoFiltro.FieldType := fdNormal;
        filtro.AddField(campoFiltro);

        campoFiltro := TFieldFilter.Create;
        campoFiltro.Description := 'Vendedor';
        campoFiltro.Name := 'NomeVendedor';
        campoFiltro.MaskTypes := mtNone;
        campoFiltro.GridSize := 100;
        campoFiltro.FieldType := fdNormal;
        filtro.AddField(campoFiltro);

        campoFiltro := TFieldFilter.Create;
        campoFiltro.Description := 'Emissão';
        campoFiltro.Name := 'DataEmissao';
        campoFiltro.MaskTypes := mtDate;
        campoFiltro.GridSize := 60;
        campoFiltro.FieldType := fdNormal;
        filtro.AddField(campoFiltro);

        campoFiltro := TFieldFilter.Create;
        campoFiltro.Description := 'Cliente';
        campoFiltro.Name := 'NomeCliente';
        campoFiltro.MaskTypes := mtNone;
        campoFiltro.GridSize := 100;
        campoFiltro.FieldType := fdNormal;
        filtro.AddField(campoFiltro);

        campoFiltro := TFieldFilter.Create;
        campoFiltro.Description := 'Vlr. Total';
        campoFiltro.Name := 'ValorTotal';
        campoFiltro.MaskTypes := mtCurrency;
        campoFiltro.FieldType := fdNormal;
        filtro.AddField(campoFiltro);

        campoFiltro := TFieldFilter.Create;
        campoFiltro.Description := ' ValorDesconto';
        campoFiltro.Name := 'ValorDesconto';
        campoFiltro.MaskTypes := mtNone;
        campoFiltro.FieldType := fdNormal;
        filtro.AddField(campoFiltro);

        campoFiltro := TFieldFilter.Create;
        campoFiltro.Description := 'ValorLiquido';
        campoFiltro.Name := 'ValorLiquido';
        campoFiltro.MaskTypes := mtNone;
        campoFiltro.GridSize := 100;
        campoFiltro.FieldType := fdNormal;
        filtro.AddField(campoFiltro);

        campoFiltro := TFieldFilter.Create;
        campoFiltro.Description := 'Caixa';
        campoFiltro.Name := 'CodigoPDV';
        campoFiltro.MaskTypes := mtNone;
        campoFiltro.FieldType := fdNormal;
        filtro.AddField(campoFiltro);

        campoFiltro := TFieldFilter.Create;
        campoFiltro.Description := 'Tipo';
        campoFiltro.Name := 'TipoOrcamento';
        campoFiltro.MaskTypes := mtNone;
        campoFiltro.GridSize := 40;
        campoFiltro.FieldType := fdNormal;
        filtro.AddField(campoFiltro);

{$ENDREGION}
        result := filtro.Execute;
    finally
        // FreeAndNil(parametro);
        // lista.Destroy;
    end;
end;

function TOrcamento.Obter(parametros: TParametro): TObject;
var
    lista: TLista<TOrcamento>;
begin
    try
        lista := baseLib.XmlToObject<TOrcamento>(baseLib.ExecutaTarefa('ConsultarOrcamento', 'TOrcamento', parametros));

        if lista.Count = 1 then
        begin
            PopularObjeto(lista[0]);
            result := Self;
        end
        else
        begin
            Tlib.MensagemAdvertencia('Nenhum registro encontrado.', 'Aviso');
            result := nil;
        end;
    finally
        lista.Destroy;
    end;
end;

procedure TOrcamento.ObterArvoreProdutosCrossSelling(item: TOrcamentoItens; treeView: TTreeView);
begin
    if item = nil then
        PreencherTreeView(treeView)
    else
        PreencheTreeViewDeletar(item, treeView);
end;

function TOrcamento.ObterCondicaoPagamentoComMaiorParcela: TOrcamentoPagamento;
var
    condPgto, maiorCondPgto: TOrcamentoPagamento;
    Parcela: integer;
begin
    maiorCondPgto := nil;
    for condPgto in Self.OrcamentoPagamento do
    begin
        if not condPgto.VerificarIgualdadeCondicaoPagamento(maiorCondPgto) then
            if Self.ObterTotalParcelas(condPgto) > Self.ObterTotalParcelas(maiorCondPgto) then
                maiorCondPgto := condPgto;
    end;
    result := maiorCondPgto;
end;

procedure TOrcamento.ObterCondicaoPagamentoOrcamento;
var
    parametro: TParametro;
begin
    try
        parametro := TParametro.Create;
        parametro.add('', 'Z9_NUM', Self.Numero);
        Self.FOrcamentoPagamento := baseLib.XmlToObject<TOrcamentoPagamento>(baseLib.ExecutaTarefa('ObterCondicaoPagamentoOrcamento', 'TOrcamento',
            parametro));
    finally
        FreeAndNil(parametro)
    end;
end;

function TOrcamento.ObterCrossSelling(item: TOrcamentoItens): boolean;
var
    resultado: TLista<TProduto>;
    produto: TProduto;
begin
    result := false;

    resultado := item.produto.ObterCrossSelling;

    if resultado <> nil then
    begin
        for produto in resultado do
        begin
            Self.AddOrcamentoItem(produto, 0);
            Self.UltimoItemAlterado.ProdutoPaiAlternativo := item.produto;
            Self.UltimoItemAlterado.TipoEntregaPaiAlternativo := item.TipoEntrega_;
            Self.UltimoItemAlterado.LocalEstoquePaiAlternativo := item.LocalEstoque;
            item.PaiAlternativo := True;
        end;
        result := True;
    end;
end;

procedure TOrcamento.ObterInformacoesMovimentoCursoSeguro(item: TOrcamentoItens);
begin

end;

function TOrcamento.ObterItem(codigo: string; validaConferido: boolean; tipoEntrega: string): TOrcamentoItens;
var
    item: TOrcamentoItens;
    achou: boolean;
    aux: string;
    prod: TProduto;
    Count: integer;
    resultFilter: TResultFilter;
begin
    result := nil;
    resultFilter := nil;
    prod := nil;
    try
        if StrToInt64Def(codigo, -1) = -1 then
        begin
            aux := trim(StringReplace(codigo, '%', '', [rfReplaceAll]));
            if Length(aux) <= 3 then
                raise Exception.Create('Descrição do produto precisa conter mais que 3 (três) caracteres');

            Count := 0;
            for item in Self.OrcamentoItens do
            begin
                if not item.produto.preenchido then
                    item.produto.Obter(item.CodigoProduto);

                if Tlib.AcharSubTextosEmUmTexto(item.produto.Descricao, codigo, '%') then
                begin
                    resultFilter := item.produto.Listar(otSelect, false, codigo);
                    if (Assigned(resultFilter)) and (resultFilter.List.Count > 0) then
                    begin
                        codigo := TProduto(resultFilter.List[0]).codigo;
                        break;
                    end
                    else
                        exit;
                end;
            end;
        end;

        for item in Self.OrcamentoItens do
        begin
            if not item.produto.preenchido then
                item.produto.Obter(item.CodigoProduto);

            if (item.produto.ChecarCodigoProduto(codigo) and ((validaConferido = false) or ((validaConferido) and (item.Conferido = false)))) and
                ((tipoEntrega = EmptyStr) or ((tipoEntrega <> EmptyStr) and (item.tipoEntrega = tipoEntrega))) then
            begin
                result := item;
                break;
            end;
        end;

    finally
        if prod <> nil then
            FreeAndNil(prod);

        if resultFilter <> nil then
            FreeAndNil(resultFilter)

    end;
end;

function TOrcamento.ObterItem(codigo: string): TOrcamentoItens;
begin
    result := ObterItem(codigo, false, '');
end;

function TOrcamento.ObterItem(codigo: string; validaConferido: boolean): TOrcamentoItens;
begin
    result := ObterItem(codigo, validaConferido, '');
end;

function TOrcamento.ObterItem(codigo, tipoEntrega: string): TOrcamentoItens;
begin
    result := ObterItem(codigo, false, tipoEntrega);
end;

procedure TOrcamento.ObterItensOrcamento;
var
    parametro: TParametro;
    hi, hf: TDateTime;
    item: TOrcamentoItens;
begin
    // hi := Now;
    try
        parametro := TParametro.Create;
        parametro.add('', 'Z6_NUM', Self.Numero);
        Self.FOrcamentoItens := baseLib.XmlToObject<TOrcamentoItens>(baseLib.ExecutaTarefa('ObterItensOrcamento', 'TOrcamento', parametro));

        //atualizar filial
        if not Self.Filial_.preenchido then
            Self.Filial_.Obter(Self.Filial);

        for item in Self.FOrcamentoItens do
        begin
            item.Filial_ := Self.Filial_;
            //somente para atualizar o tipo de entrega_
            item.TipoEntrega := item.TipoEntrega;
        end;


        // hf := now;
        // showmessage(FormatDateTime('hh:mm:ss',hf-hi));
    finally
        FreeAndNil(parametro)
    end;
end;

function TOrcamento.ObterListaDeItensParaConferencia: TList;
begin
    result := nil;
    if Self.FOrcamentoConferencia <> nil then
        result := Self.FOrcamentoConferencia.FOrcamentoItens.ToList;
end;

function TOrcamento.ObterNumeroCupomFiscalEletronico: string;
begin
    result := baseLib.XmlToString(baseLib.ExecutaTarefa('ObterNumeroCupomFiscalEletronico', 'TOrcamento', Nil));
end;

procedure TOrcamento.ObterNumeroOrcamento;
var
    param: TParametro;
    item: TOrcamentoItens;
    pagto: TOrcamentoPagamento;
begin
    try
        try
            if Self.Filial = '' then
                raise Exception.Create('Filial não preenchida.');

            param := TParametro.Create;
            param.add('', '@Z88_FILIAL', Self.Filial);
            Self.Numero := baseLib.XmlToString(baseLib.ExecutaTarefa('ObterNumeroOrcamento', 'TOrcamento', param));

            if Self.ObterQuantidadeItens = 0 then
                raise Exception.Create('Não existe itens de orçamento para preecher com o número do orçamento');

            for item in Self.OrcamentoItens do
                item.Numero := Self.Numero;

            if Self.ObterQuantidadeCondicaoPagamento = 0 then
                raise Exception.Create('Não existe condição de pagamento para preecher com o número do orçamento');

            for pagto in Self.OrcamentoPagamento do
                pagto.Numero := Self.Numero;
        except
            on e: Exception do
                raise Exception.Create('Erro ao obter o número do orçamento.' + #13 + e.Message);
        end;
    finally
        if param <> nil then
            FreeAndNil(param);
    end;
end;

function TOrcamento.ObterOrcamentoLoja: TOrcamento;
begin
    result := ObterOrcamentoFilhoPorTipo('8-EOK');
end;

procedure TOrcamento.ObterOrcamentoParaConferencia;
var
    item: TOrcamentoItens;
begin
    if FOrcamentoConferencia = nil then
    begin
        FOrcamentoConferencia := TOrcamento.Create;
        Self.CopiaCompleta := True;
        Self.CopiarPara(Self.FOrcamentoConferencia);
    end;

    for item in Self.FOrcamentoConferencia.OrcamentoItens do
        if (item.tipoEntrega <> 'LJ') then
        begin
            Self.FOrcamentoConferencia.OrcamentoItens.Delete(FOrcamentoConferencia.OrcamentoItens.IndexOf(item));
            ObterOrcamentoParaConferencia;
            break;
        end;
end;

function TOrcamento.ObterOrcamentoFilhoPorTipo(TipoOrcamento: string): TOrcamento;
var
    orcLoja: TOrcamento;
begin
    orcLoja := nil;
    result := orcLoja;
    if Self.OrcamentosFilhos <> nil then
    begin
        for orcLoja in Self.OrcamentosFilhos do
        begin
            if orcLoja.TipoOrcamento = TipoOrcamento then
            begin
                result := orcLoja;
                break;
            end;
        end;
    end;
end;

procedure TOrcamento.ObterOrcamentosFilhos;
var
    parametro: TParametro;
begin
    try
        parametro := TParametro.Create;
        parametro.add('', 'Z3_DOCORIG', TUsuarioLogado.ObterInstancia.Filial.Filial + Self.Numero);
        FOrcamentosFilhos := baseLib.XmlToObject<TOrcamento>(baseLib.ExecutaTarefa('ConsultarOrcamento', 'TOrcamento', parametro));
    finally
        if parametro <> nil then
            FreeAndNil(parametro)
    end;
end;

function TOrcamento.ObterOrcamentosLiberadosDoDia: TOrcamento;
var
    filtro: TFilter<TOrcamento>;
    parametro: TParametro;
    resultFilter: TResultFilter;
    Orcamento: TOrcamento;
    campoFiltro: TFieldFilter;
begin
    filtro := TFilter<TOrcamento>.Create;
    filtro.ScreenName := 'Filtro de Orcamentos Liberados por Dia';
    filtro.OperationType := otSelect;
    filtro.multiSelect := false;
    filtro.FilterType := ftAlredyFilteredWithParameters;
    filtro.Task := 'ConsultarOrcamento';

    campoFiltro := TFieldFilter.Create;
    campoFiltro.Description := 'Numero';
    campoFiltro.Name := 'Numero';
    campoFiltro.MaskTypes := mtNone;
    campoFiltro.GridSize := 70;
    filtro.AddField(campoFiltro);

    // campoFiltro := TFieldFilter.Create;
    // campoFiltro.Description := 'CodigoCliente';
    // campoFiltro.Name := 'CodigoCliente';
    // campoFiltro.MaskTypes := mtNone;
    // campoFiltro.GridSize := 100;
    // filtro.AddField(campoFiltro);

    campoFiltro := TFieldFilter.Create;
    campoFiltro.Description := 'NomeCliente';
    campoFiltro.Name := 'NomeCliente';
    campoFiltro.MaskTypes := mtNone;
    campoFiltro.GridSize := 100;
    filtro.AddField(campoFiltro);

    campoFiltro := TFieldFilter.Create;
    campoFiltro.Description := 'NomeVendedor';
    campoFiltro.Name := 'NomeVendedor';
    campoFiltro.MaskTypes := mtNone;
    campoFiltro.GridSize := 100;
    filtro.AddField(campoFiltro);

    campoFiltro := TFieldFilter.Create;
    campoFiltro.Description := 'ValorTotal';
    campoFiltro.Name := 'ValorTotal';
    campoFiltro.MaskTypes := mtCurrency;
    campoFiltro.GridSize := 100;
    filtro.AddField(campoFiltro);

    campoFiltro := TFieldFilter.Create;
    campoFiltro.Description := 'ValorLiquido';
    campoFiltro.Name := 'ValorLiquido';
    campoFiltro.MaskTypes := mtCurrency;
    campoFiltro.GridSize := 100;
    filtro.AddField(campoFiltro);

    parametro := TParametro.Create;
    filtro.parametro := parametro;

    parametro.add('', 'Z3_FILIAL', TUsuarioLogado.ObterInstancia.Filial.Filial);
    parametro.add('', 'Z3_EMISSAO', Tlib.ObterDataAtual('yyyymmdd'));
    parametro.add('', 'Z3_ORCLIB', '1-LIB');

    resultFilter := filtro.Execute;

    if resultFilter.List.Count = 1 then
    begin
        Orcamento := TOrcamento.Create;

        Orcamento.Obter(TOrcamento(resultFilter.List[0]).Numero);
        if Orcamento.TipoOrcamento <> '1-LIB' then
        begin
            Tlib.MensagemAdvertencia('Orçamento está sendo utilizado por outro usuário.', 'Aviso');
            result := nil;
            exit;
        end;
        TUsuarioLogado.ObterInstancia.Filial.CopiarPara(Orcamento.Filial_);
        result := Orcamento;

    end
    else
        result := nil;

    FreeAndNil(resultFilter);
end;

function TOrcamento.ObterParametrosInsercao(var parametro: TParametro; numeroOrcamentoInserir: string): TParametro;
var
    i: integer;
    orc: TOrcamento;
begin
    // Somente para o Orcamento mae
    orc := nil;
    if Self.OrcamentosFilhos <> nil then
    begin
        parametro.add('', 'QUANTIDADEORCAMENTOSFILHO', inttostr(Self.OrcamentosFilhos.Count));
    end;

    parametro.add('', 'QUANTIDADECURSOSEGURO', inttostr(Self.ObterQuantidadeItemPorTipoEntrega('CS')));

    parametro.add('', 'TIPONOTAFISCALMICROSIGA', Self.TipoNotaFiscalMicrossiga);
    parametro.add('', 'ESTACAOMICROSIGA', Self.CodigoEstacaoMS);

    parametro := ObjetoParaParametros(acInsercao, parametro, 'SZ3' + numeroOrcamentoInserir);

    for i := 0 to Self.OrcamentoItens.Count - 1 do
    begin

        if Self.TipoVenda = tvVendaRapida then
        begin
            if Self.OrcamentoItens[i].Tabela = 'T1' then
//                if not Self.Vendedor.preenchido then
//                    Self.Vendedor.Obter(Self.CodigoVendedor);
                Self.OrcamentoItens[i].Tabela := trim(Self.Vendedor.TabelaComissao);
        end;

        parametro := Self.OrcamentoItens[i].ObjetoParaParametros(acInsercao, parametro, 'SZ6' + numeroOrcamentoInserir, i + 1);

        if Self.OrcamentoItens[i].tipoEntrega = 'CS' then
            parametro := Self.OrcamentoItens[i].MovimentoCursoSeguro.ObjetoParaParametros(acInsercao, parametro,
                'SJA' + numeroOrcamentoInserir, i + 1);
    end;

    for i := 0 to Self.OrcamentoPagamento.Count - 1 do
        parametro := Self.OrcamentoPagamento[i].ObjetoParaParametros(acInsercao, parametro, 'SZ9' + numeroOrcamentoInserir, i + 1);

    i := 0;
    if Self.OrcamentosFilhos <> nil then
    begin
        for orc in Self.OrcamentosFilhos do
        begin
            i := i + 1;
            orc.ObterParametrosInsercao(parametro, inttostr(i));
        end;
    end;
end;

function TOrcamento.ObterPesoTotalItens: double;
var
    item: TOrcamentoItens;
    totalPeso: double;
begin
    totalPeso := 0;
    for item in Self.OrcamentoItens do
    begin
        // este item foi criado para melhorar performace na finalização da venda.
        if item.pesoItem <> 0 then
            totalPeso := totalPeso + (item.pesoItem * item.quantidade)
        else
        begin
            if not item.produto.preenchido then
                item.produto.Obter(item.CodigoProduto);

            totalPeso := totalPeso + (item.produto.Peso * item.quantidade);
        end;
    end;
    result := totalPeso;
end;

function TOrcamento.ObterPrazoMedioDasCondicoesPagto: double;
var
    formaPgto: TOrcamentoPagamento;
    prazoMedio: double;
    dias: double;
    qtdCondicao: integer;
begin
    prazoMedio := 0;
    dias := 0;
    if Self.OrcamentoPagamento.Count > 0 then
    begin
        for formaPgto in Self.OrcamentoPagamento do
            if formaPgto.formaPagamento <> fpAVista then
                dias := dias + (Tlib.DataSistemaParaDateTime(Tlib.ObterDataAtual) - Tlib.DataSistemaParaDateTime(formaPgto.Vencimento));

        if dias > 0 then
            prazoMedio := dias / Self.OrcamentoPagamento.Count;
    end;

    result := prazoMedio;

end;

function TOrcamento.ObterQuantidadeItens: integer;
begin
    result := FOrcamentoItens.Count;
end;

function TOrcamento.ObterQuantidadeItensConferencia: integer;
begin
    result := 0;
    if Self.FOrcamentoConferencia <> nil then
        result := Self.FOrcamentoConferencia.ObterQuantidadeItens;

end;

function TOrcamento.ObterQuantidadeItensCursoSeguro: integer;
var
    item: TOrcamentoItens;
begin
    result := 0;
    for item in Self.OrcamentoItens do
    begin
        if item.tipoEntrega = 'CS' then
            Inc(result)
    end;

end;

function TOrcamento.ObterQuantidadeOrcamentoFilhos: integer;
begin
    result := FOrcamentosFilhos.Count;
end;

function TOrcamento.ObterSerieCupomFiscalEletronico: string;
begin
    result := baseLib.XmlToString(baseLib.ExecutaTarefa('ObterSerieCupomFiscalEletronico', 'TOrcamento', Nil));
end;

function TOrcamento.ObterSimilares(produto: TProduto): boolean;
var
    resultado: TLista<TProduto>;
begin
    result := false;

    resultado := produto.ObterSimilares;

    if resultado <> nil then
    begin
        if resultado.Count > 0 then
        begin
            Self.AddOrcamentoItem(resultado[0], 0);
            result := True;
        end;
    end;
end;

function TOrcamento.ObterSimilares(item: TOrcamentoItens): boolean;
var
    produto: TProduto;
    resultado: TLista<TProduto>;
begin
    result := false;
    try
        resultado := item.produto.ObterSimilares;

        if resultado <> nil then
        begin
            if resultado.Count > 0 then
            begin
                produto := resultado[0];
                Self.AddOrcamentoItem(produto, 0);
                Self.DeletarOrcamentoItem(item, item.PaiAlternativo);
                result := True;
            end;
        end;
    except
        on e: Exception do
        begin
            Tlib.MensagemErro('Erro ao adicionar produto Similar!',e.Message);
        end;
    end;
end;

procedure TOrcamento.ObterTotaisOrcamento;
var
    item: TOrcamentoItens;
    Valor: Currency;
begin
    ZerarTotais;
    for item in OrcamentoItens do
    begin
        Self.FValorDespesa := Self.ValorDespesa + item.ValorDespesa;
        Self.FValorSeguro := Self.ValorSeguro + item.ValorSeguro;
        Self.FValorFrete := Self.ValorFrete + item.ValorFrete;
        // Self.FValorIcms := Self.FValorIcms + item.ValorIcms;
        Self.FValorMercadoria := ValorMercadoria + item.ValorTotal;
        Self.FValorDesconto := Self.ValorDesconto + item.ValorDesconto;
        // estes itens tem que ser zerado pois não foi definido pela contabilidade se vai ser combrado do cliente ou não.
        Self.FValorSubstituicao := 0; // Self.FValorSubstituicao + item.ValorIcmsRetido;

        if item.EmPromocao then
            Self.FValorPromocao := Self.ValorPromocao + item.ValorTotal;

        Self.FValorIpi := 0;

        Valor := (item.PrecoTabela * item.quantidade) - (item.ValorUnitario * item.quantidade);

        if Valor > 0 then
            Self.FValorDescontoTotalNegociado := Self.FValorDescontoTotalNegociado + Valor
        else if Valor < 0 then
            Self.FValorAcrescimosTotalNegociado := Self.ValorAcrescimosTotalNegociado + (Valor * (-1));
    end;

    Self.FValorTotal := Self.ValorMercadoria + Self.ValorFrete + Self.ValorSeguro + Self.ValorDespesa;
    Self.FValorLiquido := (Self.ValorMercadoria - Self.ValorDesconto) + Self.ValorFrete + Self.ValorSeguro + Self.ValorDespesa;
    Self.FValorBruto := Self.ValorTotal;

    Self.FValorPagoDinheiro := Self.ObterValorTotalCondicaoPagamento(fpAVista);
    Self.FValorPagoCartaoCredito := Self.ObterValorTotalCondicaoPagamento(fpCartaoCredito);
    Self.FValorPagoCartaoDebito := Self.ObterValorTotalCondicaoPagamento(fpCartaoDebito);
    Self.FValorPagoCheque := Self.ObterValorTotalCondicaoPagamento(fpCheque);
    Self.FValorPagoFinan := Self.ObterValorTotalCondicaoPagamento(fpFinanciamento);
    Self.FValorPagoDuplicata := Self.ObterValorTotalCondicaoPagamento(fpDuplicata);

    Self.FPesoBruto := ObterPesoTotalItens;
    Self.FPesoLiquido := ObterPesoTotalItens;

    Self.ValorDescontoTotalNegociado := Self.ValorDescontoTotalNegociado + Self.ValorDesconto;
    Self.ValorAcrescimosTotalNegociado := Self.ValorAcrescimosTotalNegociado + Self.ValorDespesa;
end;

function TOrcamento.ObterQuantidadeTotalItens: double;
var
    item: TOrcamentoItens;
    totalQuantidade: double;
begin
    totalQuantidade := 0;
    for item in Self.OrcamentoItens do
        totalQuantidade := totalQuantidade + item.quantidade;

    result := totalQuantidade;
end;

function TOrcamento.ObterQuantidadeCondicaoPagamento: integer;
begin
    result := FOrcamentoPagamento.Count;
end;

function TOrcamento.ObterTotalDosImpostosDilma: double;
var
    item: TOrcamentoItens;
begin
    result := 0;
    for item in Self.OrcamentoItens do
        result := result + item.ImpostoDilma;

end;

function TOrcamento.ObterTotalItensConferidos: integer;
var
    item: TOrcamentoItens;
begin
    result := 0;
    for item in Self.FOrcamentoConferencia.OrcamentoItens do
        if item.Conferido then
            result := result + 1;
end;

function TOrcamento.ObterTotalPorTipoParaRateio(Tipo: String; var tiposDeEntrega: string): double;
var
    item: TOrcamentoItens;
    entrega, movimentoCD, vendaOutraLoja, resto: boolean;
    TiposEntrega, tiposMovimentoCD, tiposResto: String;
begin
    try
        result := 0;
        entrega := false;
        movimentoCD := false;
        vendaOutraLoja := false;
        resto := false;
        TiposEntrega := 'CD/EL/CE/LE';
        tiposMovimentoCD := 'PE/RC/TF';
        tiposResto := 'CS/' + TiposEntrega + '/' + tiposMovimentoCD;
        tiposDeEntrega := '';

        for item in Self.OrcamentoItens do
        begin
            if Tipo = 'ENTREGA' then
            begin
                if pos(item.tipoEntrega, TiposEntrega) > 0 then
                begin
                    result := result + item.ValorTotal;
                    tiposDeEntrega := tiposDeEntrega + '/' + item.tipoEntrega;
                    entrega := True;
                end;
            end
            else if Tipo = 'MOVCD' then
            begin
                if pos(item.tipoEntrega, tiposMovimentoCD) > 0 then
                begin
                    result := result + item.ValorTotal;
                    tiposDeEntrega := tiposDeEntrega + '/' + item.tipoEntrega;
                    movimentoCD := True;
                end;
            end
            else if Tipo = 'VOL' then
            begin
                if StrToIntDef(item.tipoEntrega, -1) > 0 then
                begin
                    result := result + item.ValorTotal;
                    tiposDeEntrega := tiposDeEntrega + '/' + item.tipoEntrega;
                    vendaOutraLoja := True;
                end;
            end
            else
            begin
                if (pos(item.tipoEntrega, tiposResto) = 0) and (StrToIntDef(item.tipoEntrega, -1) < 0) then
                begin
                    result := result + item.ValorTotal;
                    tiposDeEntrega := tiposDeEntrega + '/' + item.tipoEntrega;
                    resto := True;
                end;
            end;
        end;
    except
        result := 0;
        tiposDeEntrega := '';
    end;
end;

function TOrcamento.ObterTotalParcelas(condicaoPgto: TOrcamentoPagamento): integer;
var
    condicao: TOrcamentoPagamento;
    cont: integer;
begin
    cont := 0;
    for condicao in Self.OrcamentoPagamento do
    begin
        if condicao.VerificarIgualdadeCondicaoPagamento(condicaoPgto) then
        begin
            cont := cont + 1;
        end;
    end;
    result := cont;
end;

function TOrcamento.ObterTotalPrecoTabela: double;
var
    item: TOrcamentoItens;
begin
    result := 0;
    for item in OrcamentoItens do
    begin
        result := result + (item.quantidade * item.PrecoTabela);
    end;
end;

function TOrcamento.ObterTotalProdutosDiferenteDeCursoSeguro(var tipos: String): double;
var
    item: TOrcamentoItens;
begin
    try
        result := 0;
        tipos := '';
        for item in OrcamentoItens do
        begin
            if item.tipoEntrega <> 'CS' then
            begin
                result := result + item.ValorTotal;
                tipos := tipos + '/' + item.tipoEntrega;
            end;
        end;
    except
        result := 0;
    end;
end;

function TOrcamento.ObterUpSelling(produto: TProduto): boolean;
var
    resultado: TLista<TProduto>;
begin
    result := false;

    resultado := produto.ObterUpSelling;

    if resultado <> nil then
    begin
        if resultado.Count > 0 then
        begin
            Self.AddOrcamentoItem(resultado[0], 0);
            result := True;
        end;
    end;
end;

function TOrcamento.ObterUpSelling(item: TOrcamentoItens): boolean;
var
    produto: TProduto;
    resultado: TLista<TProduto>;
begin
    result := false;
    try
        resultado := item.produto.ObterUpSelling;

        if resultado <> nil then
        begin
            if resultado.Count > 0 then
            begin
                produto := resultado[0];
                Self.AddOrcamentoItem(produto, 0);
                Self.DeletarOrcamentoItem(item, item.PaiAlternativo);
                result := True;
            end;
        end;
    except
        on e: Exception do
        begin
            Tlib.MensagemErro('Erro ao adicionar produto Up Selling',e.Message);
        end;
    end;
end;

function TOrcamento.ObterValorTotalCondicaoPagamento(formaPg: TFormaPagamento; administradora, sequenciamentoCartao: string): double;
var
    formaPgto: TOrcamentoPagamento;
begin
    result := 0;
    for formaPgto in Self.OrcamentoPagamento do
    begin
        if (formaPgto.formaPagamento = formaPg) and
            ((formaPgto.administradora = administradora) and (formaPgto.sequenciamentoCartao = sequenciamentoCartao) or
            ((administradora = EmptyStr) and (sequenciamentoCartao = EmptyStr))) then
        begin
            result := result + formaPgto.ValorParcela;
        end;
    end;
end;

procedure TOrcamento.ObterValorParaRateio(var valorDosProduto: double; var tipos: String; tipoDoRateio: TTipoDeRateio);
begin
    valorDosProduto := 0;
    tipos := '';
    if tipoDoRateio = trDespesas then
    begin
        tipos := '';
        { Regra: 2.1.1. 9-ENT / 9-ENL / 9-ECD / 9-ECO: Priorizar as entregas feita pela todimo. }
        valorDosProduto := ObterTotalPorTipoParaRateio('ENTREGA', tipos);

        { 2.1.2. 9-PSE / 9-RCD / 9-TFF: Priorizar as modalidades que são movimentadas pelo CD }
        if valorDosProduto = 0 then
            valorDosProduto := ObterTotalPorTipoParaRateio('MOVCD', tipos);

        { 2.1.3. 9-VOL: Priorizar venda em outra loja. }
        if valorDosProduto = 0 then
            valorDosProduto := ObterTotalPorTipoParaRateio('VOL', tipos);

        { 2.1.4. Retear para todos os produtos. }
        if valorDosProduto = 0 then
            valorDosProduto := ObterTotalPorTipoParaRateio('RESTO', tipos);
    end
    else
    begin
        valorDosProduto := ObterTotalProdutosDiferenteDeCursoSeguro(tipos);
    end;
end;

function TOrcamento.ObterValorRestanteParaPagamento: double;
begin
    ObterTotaisOrcamento;
    result := (Self.ValorLiquido - ObterValorTotalTodasCondicoesPagamento);
end;

function TOrcamento.ObterValorTotalCondicaoPagamento(formaPg: TFormaPagamento): double;
begin
    result := Self.ObterValorTotalCondicaoPagamento(formaPg, EmptyStr, EmptyStr);
end;

function TOrcamento.ObterValorTotalCondicaoPagamento(condicaoPgto: TOrcamentoPagamento): double;
begin
    result := ObterValorTotalCondicaoPagamento(condicaoPgto.formaPagamento, condicaoPgto.administradora, condicaoPgto.sequenciamentoCartao);
end;

function TOrcamento.ObterValorTotalTodasCondicoesPagamento: double;
var
    formaPgto: TOrcamentoPagamento;
    total: double;
begin
    total := 0;
    for formaPgto in Self.OrcamentoPagamento do
        total := total + formaPgto.ValorParcela;

    result := total;
end;

function TOrcamento.Obter(ID: string): TObject;
var
    parametros: TParametro;

begin
    try
        parametros := TParametro.Create;
        parametros.add('', 'Z3_NUM', ID);
        parametros.add('', 'Z3_FILIAL', TUsuarioLogado.ObterInstancia.Filial.Filial);
        result := Obter(parametros);
    finally
        FreeAndNil(parametros);
    end;
end;

{$ENDREGION}
{$REGION 'Regras de Negócio'}

procedure TOrcamento.PopularObjeto(Orcamento: TOrcamento);
begin
    Orcamento.CopiarPara(Self);
    FPreenchido := True;
end;

procedure TOrcamento.CalcularValorEntradaPagamento(valorRateio: double);
var
    valorMaximoEntrada: Currency;
begin
    try
        if (Self.ValorEntrada <> valorRateio) and (Self.TabelaComissao.CodigoTabela <> 'T1') then
        begin
            Self.ValorEntrada := valorRateio;
            { Valida o valor da entrada }
            if (TabelaComissao.PercentualMaximoEntrada > 0) and (Self.ValorLiquido > 0) then
            begin
                valorMaximoEntrada := (Self.ValorLiquido / 100) * TabelaComissao.PercentualMaximoEntrada;
                if valorRateio > valorMaximoEntrada then
                    raise Exception.Create('A entrada dever ser menor que ' + CurrToStr(TabelaComissao.PercentualMaximoEntrada) +
                        '% do valor total do orçamento');
            end;

            { Valida que a entrada não pode ser maior que valor do orçamento }
            if valorRateio >= Self.ValorLiquido then
                raise Exception.Create('A entrada dever ser menor que o valor total do orçamento');

            if TabelaComissao.CodigoTabela <> 'T1' then
            begin
                RecalcularPrecoEmTabelaComissao;
            end
            else
                Self.ValorEntrada := valorRateio;
            ObterTotaisOrcamento;
        end;
    except
        on e: Exception do
        begin
            raise Exception.Create('Erro ao ratear valor entrada'#13 + e.Message);
        end;
    end;
end;

procedure TOrcamento.RatearValoresNosItens(valorRateio: double; nomeCampoParaRateio: String; tipoDoRateio: TTipoDeRateio);
var
    coeficiente, valorProdutos, somaDosValoresRateados, diferenca, valorParaArredondamento, valorRateadoNoItem, Valor: double;
    tipos: String;
    estaCerto: boolean;
    item: TOrcamentoItens;
begin
{$REGION 'Regras para rateio'}
    {
      1. Regra principal:
      1.1. Produtos do tipo curso ou seguro, numca poderão receber nenhum tipo de rateio.

      2. Rateio de Valor de Despesas
      2.1. Priorizar o rateio do valor da despesa para os tipos de entregas na seguinte ordem:
      2.1.1. 9-ENT / 9-ENL / 9-ECD / 9-ECO: Priorizar as entregas feita pela todimo.
      2.1.2. 9-PSE / 9-RCD / 9-TFF: Priorizar as modalidades que são movimentadas pelo CD
      2.1.3. 9-VOL: Priorizar venda em outra loja.
      2.1.4. Retear para todos os produtos.

      3. Demais valores rateados, obedecer a regra 1 e ratear para os demais produtos.
    }
{$ENDREGION}
    if Self.ObterQuantidadeItens <= 0 then
        exit;
    try
        if valorRateio = 0 then
        begin
            ZerarRateioValoresNosItens(nomeCampoParaRateio);
            if tipoDoRateio = trDesconto then
                Self.FPercDesconto := 0;
        end
        else
        begin

            ZerarRateioValoresNosItens(nomeCampoParaRateio);
            tipos := '';

            { Itens 1 e 3 das regras }
            if ObterTotalProdutosDiferenteDeCursoSeguro(tipos) > 0 then
            begin
                ObterValorParaRateio(valorProdutos, tipos, tipoDoRateio);

                if (valorProdutos > 0) and (tipos <> '') then
                begin
                    { Acha o coeficiente de desconto }
                    coeficiente := valorRateio / valorProdutos;

                    { Atualiza os itens }
                    for item in Self.OrcamentoItens do
                    begin
                        if pos(item.tipoEntrega, tipos) > 0 then
                        begin
                            Valor := Tlib.ArredondarNumero((item.ValorTotal * coeficiente));
                            item.SetarValorPorNomePropriedade(nomeCampoParaRateio, CurrToStr(Valor));
                        end;
                    end;

                    { Ajusta o valor rateado, até a soma do rateio ficar igual ao valor digitado }
                    estaCerto := false;
                    while estaCerto = false do
                    begin
                        { Soma o valor rateado }
                        somaDosValoresRateados := 0;
                        for item in Self.OrcamentoItens do
                            somaDosValoresRateados := somaDosValoresRateados + StrToFloat(item.ObterValorPorNomePropriedade(nomeCampoParaRateio));

                        { Calcula a diferença }
                        diferenca := Tlib.ArredondarNumero((somaDosValoresRateados - valorRateio));

                        if diferenca <> 0 then
                        begin
                            if diferenca > 0 then
                                valorParaArredondamento := -0.01
                            else
                                valorParaArredondamento := 0.01;

                            { Ajusta o valor nos produtos }
                            for item in Self.OrcamentoItens do
                            begin
                                if pos(item.tipoEntrega, tipos) > 0 then
                                begin
                                    if StrToFloat(item.ObterValorPorNomePropriedade(nomeCampoParaRateio)) < 0 then
                                        valorRateadoNoItem := StrToFloat(item.ObterValorPorNomePropriedade(nomeCampoParaRateio)) * -1
                                    else
                                        valorRateadoNoItem := StrToFloat(item.ObterValorPorNomePropriedade(nomeCampoParaRateio));

                                    if (valorRateadoNoItem > 0.01) or (valorParaArredondamento = 0.01) then
                                    begin
                                        Valor := (StrToFloat(item.ObterValorPorNomePropriedade(nomeCampoParaRateio)) + (valorParaArredondamento));
                                        item.SetarValorPorNomePropriedade(nomeCampoParaRateio, CurrToStr(Valor));
                                        somaDosValoresRateados := somaDosValoresRateados + (valorParaArredondamento);

                                        if Tlib.ArredondarNumero(valorRateio) = Tlib.ArredondarNumero(somaDosValoresRateados) then
                                        begin
                                        estaCerto := True;
                                        break;
                                        end;
                                    end;
                                end;
                            end;
                        end
                        else
                        begin
                            estaCerto := True;
                        end;
                    end;

                    if tipoDoRateio = trDesconto then
                        Self.FPercDesconto := Tlib.ArredondarNumero(((valorRateio * 100) / valorProdutos));
                end
                else
                begin
                    raise Erro.Create('Não existe itens para rateio!', MSGInformacao);
                end;
            end
            else
            begin
                raise Erro.Create('Não existe itens para rateio!', MSGInformacao);
            end;
        end;
    finally
        Self.ObterTotaisOrcamento;
    end;
end;

procedure TOrcamento.RatearValoresNosItens;
begin
    if Self.ValorDesconto <> 0 then
        RatearValoresNosItens(Self.ValorDesconto, 'ValorDesconto', trDesconto);

    if Self.ValorDespesa <> 0 then
        RatearValoresNosItens(Self.ValorDespesa, 'ValorDespesa', trDespesas);

    if Self.ValorSeguro <> 0 then
        RatearValoresNosItens(Self.ValorSeguro, 'ValorSeguro', trSeguro);

    if Self.ValorFrete <> 0 then
        RatearValoresNosItens(Self.ValorFrete, 'ValorFrete', trFrete);
end;

procedure TOrcamento.RecalcularComissoesAplicadas;
var
    item: TOrcamentoItens;
    prazoMedio: double;
begin
    if Self.ObterQuantidadeCondicaoPagamento = 0 then
        raise Erro.Create('Para calcular a comissão é obrigatório informa uma condição de pagamento!');

    prazoMedio := Self.ObterPrazoMedioDasCondicoesPagto;

    for item in Self.OrcamentoItens do
        item.CalcularComissaoAplicada(prazoMedio);

end;

procedure TOrcamento.RecalcularImpostoItens;
var
    item: TOrcamentoItens;
begin
    if not Self.Cliente.preenchido then
        Self.Cliente.Obter(Self.SequencialCliente, Self.CodigoCliente);

    for item in Self.OrcamentoItens do
        item.CalcularImposto(Self.Cliente.Estado, Self.Cliente.Tipo, Self.Cliente.TipoPessoa, Self.TipoDaVenda, Self.CupomOuNotaFiscal);

end;

procedure TOrcamento.RecalcularPrecoEmTabelaComissao;
var
    item: TOrcamentoItens;
    totalPrecoTabela: double;
begin
    totalPrecoTabela := ObterTotalPrecoTabela;
    for item in OrcamentoItens do
    begin
        item.CalcularPrecoEmTabela(TabelaComissao, TabelaComissaoQuantidadeParcelas, totalPrecoTabela, Self.ValorEntrada);
    end;
end;

procedure TOrcamento.RestauraItensConferidos;
var
    arq, orc, aux, cod, qtdConf: string;
    item: TOrcamentoItens;
    arquivo: TextFile;
begin
    try
        try
            arq := ExtractFilePath(Application.ExeName) + 'ORCCONF.txt';

            if FileExists(arq) then
            begin
                AssignFile(arquivo, arq);
                Reset(arquivo);
                Readln(arquivo, orc);
                if orc = Self.Numero then
                begin
                    if Tlib.MensagemPergunta('Este orçamento possui itens que já foram conferidos. Deseja reconferí-los?', 'Pergunta', 0) = mrNo then
                    begin
                        while not Eof(arquivo) do
                        begin
                            Readln(arquivo, aux);
                            cod := Tlib.ObterPorParametro(aux, '1', '|');
                            qtdConf := Tlib.ObterPorParametro(aux, '2', '|');
                            for item in Self.FOrcamentoConferencia.OrcamentoItens do
                            begin
                                if item.CodigoProduto = cod then
                                begin
                                    // validação caso o vendedor diminua a quantidade de itens do orcamento
                                   if (CompareValue( strtoFloatDef(qtdConf, 1), item.quantidade) = LessThanValue) or
                                      (CompareValue( strtoFloatDef(qtdConf, 1), item.quantidade) = EqualsValue) then
                                         item.QuantidadeConferida := strtoFloatDef(qtdConf, 1);
                                end;
                            end;
                        end;
                    end;
                end;
                closefile(arquivo);
            end;

        except
            Tlib.MensagemAdvertencia('Falha ao tentar restaurar o arquivo com os itens conferidos.', 'Aviso');
        end;
    finally

    end;

end;

procedure TOrcamento.AtualizarFilhosCrossSelling(itemAtual, itemAnterior: TOrcamentoItens);
var
    itemOrc: TOrcamentoItens;
begin
    if itemAnterior.PaiAlternativo then
    begin
        for itemOrc in Self.OrcamentoItens do
        begin
            if itemOrc.ProdutoPaiAlternativo <> nil then
            begin
                if (itemOrc.ProdutoPaiAlternativo.codigo = itemAnterior.CodigoProduto) and
                    (itemOrc.LocalEstoquePaiAlternativo = itemAnterior.LocalEstoque) and
                    (itemOrc.TipoEntregaPaiAlternativo.tipoEntrega = itemAnterior.tipoEntrega) then
                begin
                    if itemAtual <> nil then
                    begin
                        itemOrc.ProdutoPaiAlternativo := itemAtual.produto;
                        itemOrc.TipoEntregaPaiAlternativo := itemAtual.TipoEntrega_;
                        itemOrc.LocalEstoquePaiAlternativo := itemAtual.LocalEstoque;
                    end
                    else
                    begin
                        itemOrc.ProdutoPaiAlternativo := nil;
                        itemOrc.TipoEntregaPaiAlternativo := nil;
                        itemOrc.LocalEstoquePaiAlternativo := '';
                    end;
                end;
            end;
        end;
    end;
end;

procedure TOrcamento.AtualizarMovimentoCursoSeguro;
var
    item: TOrcamentoItens;
begin
    try
        for item in OrcamentoItens do
        begin
            if item.tipoEntrega = 'CS' then
            begin
                if not item.produto.preenchido then
                begin
                    item.produto.Obter(item.CodigoProduto);
                    item.produto.CursoSeguro.Obter(item.produto.CodigoCursoSeguro);
                end;

                if Self.TipoDaVenda <> 'VR' then
                begin
                    item.obterMovimentoCursoSeguro;
                end
                else
                begin
                    item.MovimentoCursoSeguro.Orcamento := Self.Numero;
                    item.MovimentoCursoSeguro.PercentualPremio := item.PercentualComissao;
                    item.MovimentoCursoSeguro.ItemMae := item.item;
                    item.MovimentoCursoSeguro.produto := item.CodigoProduto;
                    item.MovimentoCursoSeguro.CodigoCursoSeguro := item.produto.CursoSeguro.codigo;
                    item.MovimentoCursoSeguro.ValorPagar := item.ValorTotal;
                    item.MovimentoCursoSeguro.ValorReceber := RoundTo((item.ValorTotal * item.produto.CursoSeguro.Percentual) / 100, -2);
                    item.MovimentoCursoSeguro.Filial := TUsuarioLogado.ObterInstancia.Filial.Filial;
                    item.MovimentoCursoSeguro.Status := 'S';
                    item.MovimentoCursoSeguro.ValorDevolvido := 0;

                    item.MovimentoCursoSeguro.ValorCapitalizacao := item.produto.CursoSeguro.ValorCapitalizacao;
                    item.MovimentoCursoSeguro.ValorDiariaIndenizacao := item.produto.CursoSeguro.ValorDiariaIndenizacao;
                    item.MovimentoCursoSeguro.QuantidadeDiasMaximoIndenizacao := item.produto.CursoSeguro.QuantidadeDiasMaximoIndenizacao;
                    item.MovimentoCursoSeguro.PercentualIOF := item.produto.CursoSeguro.PercentualIOF;

                    // preenche com numero do range
                    item.MovimentoCursoSeguro.ObterNumeroRange(Self.Usuario, Self.CodigoEstacaoMS, false);

                    // if item.Produto.CursoSeguro.TipoSeguro_ = tsAcidentePessoal then
                    // item.MovimentoCursoSeguro.ObterNumeroRange(Self.Usuario, Self.CodigoEstacaoMS, false) // preenche tbm data ultimo sorteio, numero sorte, serie
                    // else
                    // item.MovimentoCursoSeguro.ObterNumeroRange(Self.Usuario, Self.CodigoEstacaoMS, true); // preenche somente numero e item range

                    if item.produto.TipoProduto = tpSeguro then
                    begin
                        item.MovimentoCursoSeguro.TipoMovimento := 'I'; // I-Inclusao, A-Alteracao, E-Exclusao, M-Manutencao,
                        item.MovimentoCursoSeguro.DataMovimentacao := Self.DataEmissao;
                        item.MovimentoCursoSeguro.NumeroChubb := item.produto.CursoSeguro.NumeroChub;
                        item.MovimentoCursoSeguro.SubGrupo := Self.Filial_.CodigoChubb;
                        item.MovimentoCursoSeguro.NumeroCertificado := '0000000001';
                        item.MovimentoCursoSeguro.DigitoCPF := '00'; // RightStr(Self.Cliente.Cgc,2);
                        item.MovimentoCursoSeguro.VigenciaInicio := Tlib.IncrementaData<String>(item.MovimentoCursoSeguro.DataMovimentacao,
                            item.produto.CursoSeguro.VigenciaInicial);
                        item.MovimentoCursoSeguro.VigenciaFim := Tlib.IncrementaData<String>(item.MovimentoCursoSeguro.VigenciaInicio,
                            item.produto.CursoSeguro.VigenciaFinal);
                        item.MovimentoCursoSeguro.ValorCobertura := item.produto.CursoSeguro.ValorCoberturaSeguro1;
                        item.MovimentoCursoSeguro.ValorPremio := item.produto.PrecoAtualProduto;
                        item.MovimentoCursoSeguro.StatusCobranca := 'P'; // P- pago/I-inadimplente/ " "- nao se applica
                        item.MovimentoCursoSeguro.Servico := item.produto.CursoSeguro.Servico + '00000000';

                        if item.produto.CursoSeguro.TipoSeguro_ = tsAcidentePessoal then
                        begin
                            // já pego essas informações lá em cima no metodo obterRange
                            // item.MovimentoCursoSeguro.DataUltimoSorteio :=  ''; // pegar do range
                            // item.MovimentoCursoSeguro.SerieTC := ''; //Pegar do Rage
                            // item.MovimentoCursoSeguro.NumeroSorteioTC := '';  //Pegar do rage
                        end
                        else if item.produto.CursoSeguro.TipoSeguro_ = tsPrestamista then
                        begin
                            item.MovimentoCursoSeguro.ISCobertura1 := item.produto.CursoSeguro.ValorCoberturaSeguro1;
                            item.MovimentoCursoSeguro.ISCobertura2 := item.produto.CursoSeguro.ValorCoberturaSeguro2;

                            item.MovimentoCursoSeguro.SaldoDevedor := Self.ValorTotal; // Valor total da compra
                            item.MovimentoCursoSeguro.Parcelas := Self.ObterTotalParcelas(Self.ObterCondicaoPagamentoComMaiorParcela);
                            // numero maior parcela
                            item.MovimentoCursoSeguro.Contrato := Self.Filial + Self.Numero + item.item + item.produto.codigo + '000';
                            item.MovimentoCursoSeguro.DataInicioContrato := Tlib.IncrementaData<string>(Self.DataEmissao, 1); // data venda + 1
                            item.MovimentoCursoSeguro.DataFimContrato := Self.ObterCondicaoPagamentoComMaiorParcela.Vencimento;
                            // sera prenechido com a data da ultima parcela

                            if item.MovimentoCursoSeguro.DataInicioContrato > item.MovimentoCursoSeguro.DataFimContrato then
                                item.MovimentoCursoSeguro.DataFimContrato := item.MovimentoCursoSeguro.DataInicioContrato;

                            item.MovimentoCursoSeguro.ValorCompra := Self.ValorTotal; // Preencher com valor total da compra
                            item.MovimentoCursoSeguro.ValorParcela := Self.ValorTotal / item.MovimentoCursoSeguro.Parcelas; // Valor da parcela
                        end
                        else if item.produto.CursoSeguro.TipoSeguro_ = tsResidencial then
                        begin

                        end;
                    end
                    else if item.produto.TipoProduto = tpCurso then
                    begin
                        item.MovimentoCursoSeguro.telefone := Self.Cliente.telefone;

                    end;
                end;
                item.MovimentoCursoSeguro.Status := 'S';
                item.MovimentoCursoSeguro.DataEmissao := Self.DataEmissao;
                // Preeche numero bilhete
                item.MovimentoCursoSeguro.ObterNumeroBilhete;
            end;
        end;
    except
        on e: Exception do
            raise Exception.Create('Erro atualizar informações de curso e seguro' + #13 + e.Message);
    end;
end;

procedure TOrcamento.AtualizarNumeroDocumentoNosItens(NumeroDocumento, serie: string);
var
    item: TOrcamentoItens;
begin
    for item in OrcamentoItens do
    begin
        item.NumeroDocumento := NumeroDocumento;
        item.SerieDocumento := serie;
    end;
end;

procedure TOrcamento.AtualizarTabelaComissaoItens;
var
    item: TOrcamentoItens;
begin
    for item in OrcamentoItens do
    begin
        item.Tabela := TabelaComissao.CodigoTabela;
    end;
end;

procedure TOrcamento.AtualizarTabelasDeComissao;
var
    item: TOrcamentoItens;
begin
    if not Self.Vendedor.preenchido then
        raise Exception.Create('Vendedor não foi preenchido, impossibilitando a atualização das tabelas de comissão.');

    for item in OrcamentoItens do
        item.Tabela := trim(Self.Vendedor.TabelaComissao);

end;

function TOrcamento.ValidarCaracteresInvalidosNosItens: boolean;
var
    item: TOrcamentoItens;
begin
    result := True;
    for item in OrcamentoItens do
        if not item.produto.ValidarCaracteresInvalidosDescricao then
        begin
            result := false;
            exit;
        end;

end;

function TOrcamento.ValidarConferencia(produto: string; out item: TOrcamentoItens): boolean;
begin
    result := True;
    item := Self.FOrcamentoConferencia.ObterItem(produto, True);
    if (item <> nil) then
    begin
        if item.Conferido then
        begin
            Tlib.MensagemInformacao('Item já foi conferido');
            result := false;
        end;
        if (item.Produto.ProdutoSelfColor) and (item.ItemPai <> emptyStr) then
        begin
            Tlib.MensagemInformacao('Item SeffColor não pode ser conferido');
            result := false;
        end;


    end
    else
    begin
        Tlib.MensagemInformacao('Item não consta na lista de conferência');
        result := false;
    end;
end;

function TOrcamento.VerificarExistenciaOrcamentoParaEntrega: boolean;
var
    orc: TOrcamento;
begin
    result := false;
    for orc in Self.OrcamentosFilhos do
        if (orc.TipoOrcamento <> '8-EOK') and (orc.TipoOrcamento <> '6-FUT') then
            result := True;
end;

function TOrcamento.ObterQuantidadeItemPorTipoEntrega(entrega: string): integer;
var
    item: TOrcamentoItens;
begin
    result := 0;
    for item in Self.OrcamentoItens do
    begin
        // if not item.Produto.Preenchido then
        // item.Produto.Obter(item.CodigoProduto);

        if (trim(item.tipoEntrega) = entrega) then
            Inc(result)
    end;
end;

function TOrcamento.VerificarQuantidadeItensForaDaLoja: integer;
var
    itensLoja, itensForaLoja: integer;
begin
    itensLoja := Self.ObterQuantidadeItemPorTipoEntrega('LJ');
    itensLoja := itensLoja + ObterQuantidadeItemPorTipoEntrega('DL');
    itensLoja := itensLoja + ObterQuantidadeItemPorTipoEntrega('CS');
    result := Self.ObterQuantidadeItens - itensLoja;
end;

function TOrcamento.VeriricarExistenciaParcelasVencidas: boolean;
var
    formaPgto: TOrcamentoPagamento;
begin
    result := false;
    if Self.OrcamentoPagamento.Count > 0 then
    begin
        for formaPgto in Self.OrcamentoPagamento do
            if formaPgto.Vencimento < Tlib.ObterDataAtual then
                result := True;
    end;
end;

{$ENDREGION}
{$REGION 'Métodos de Propriedades'}

function TOrcamento.SelecionarTipoEntrega(item: TOrcamentoItens): TTipoEntrega;
begin
    result := nil;

    if (Self.Cliente.codigo = Self.Cliente.CodigoClientePadrao) and (Self.Cliente.Sequencial = Self.Cliente.SeguencialClientePadrao) then
        raise Exception.Create('Não é permitido incluir tipos de entrega para cliente consumidor final');

    if trim(item.tipoEntrega) = 'CS' then
        exit;

    if item.produto.ProdutoLiberadoConferenciaFiscal = false then
        raise Erro.Create('Este produto pode ser vendido, somente para Encomenda');

    // Self.Filial_.ObterListaTipoEntrega(tvVendaBalcao);

    frmSelecionarTipoEntrega := TfrmSelecionarTipoEntrega.Create(Application.MainForm);
    frmSelecionarTipoEntrega.Orcamento := Self;
    frmSelecionarTipoEntrega.produto := item.produto;
    frmSelecionarTipoEntrega.ShowModal;

    if frmSelecionarTipoEntrega.TipoEntregaSelecionado = nil then
    begin
        FreeAndNil(frmSelecionarTipoEntrega);
        result := nil;
        exit;
    end;

    result := TTipoEntrega.Create;
    frmSelecionarTipoEntrega.TipoEntregaSelecionado.CopiarPara(result);

    FreeAndNil(frmSelecionarTipoEntrega);
end;

procedure TOrcamento.SetBairro(const Value: string);
begin
    FBairro := Value;
end;

procedure TOrcamento.SetBaseICMSRestido(const Value: double);
begin
    FBaseICMSRestido := Value;
end;

procedure TOrcamento.SetCep(const Value: string);
begin
    FCep := Value;
end;

procedure TOrcamento.SetCliente(const Value: TCliente);
begin
    FCliente := Value;
end;

procedure TOrcamento.SetCodigoCliente(const Value: string);
begin
    FCodigoCliente := Value;
end;

procedure TOrcamento.SetCodigoEstacaoMS(const Value: String);
begin
    FCodigoEstacaoMS := Value;
end;

procedure TOrcamento.SetCodigoFormaPagto(const Value: string);
begin
    FCodigoFormaPagto := Value;
end;

procedure TOrcamento.SetCodigoOperadorPDV(const Value: string);
begin
    FCodigoOperadorPDV := Value;
end;

procedure TOrcamento.SetCodigoOrcamentoOrigem(const Value: string);
begin
    FCodigoOrcamentoOrigem := Value;
end;

procedure TOrcamento.SetCodigoPDV(const Value: string);
begin
    FCodigoPDV := Value;
end;

procedure TOrcamento.SetCodigoTransportadora(const Value: string);
begin
    FCodigoTransportadora := Value;
end;

procedure TOrcamento.SetCodigoVeiculoTransportadora(const Value: string);
begin
    FCodigoVeiculoTransportadora := Value;
end;

procedure TOrcamento.SetCodigoVendedor(const Value: string);
begin
    FCodigoVendedor := Value;
end;

procedure TOrcamento.SetControleEntrega(const Value: string);
begin
    FControleEntrega := Value;
end;

procedure TOrcamento.SetCopiaCompleta(const Value: boolean);
begin
    FCopiaCompleta := Value;
end;

procedure TOrcamento.SetCPFCNPJImpressao(const Value: string);
begin
  FCPFCNPJImpressao := Value;
end;

procedure TOrcamento.SetCreditosCliente(const Value: TLista<TCreditoCliente>);
begin
    FCreditosCliente := Value;
end;

procedure TOrcamento.SetDataDigitacao(const Value: string);
begin
    FDataDigitacao := Value;
end;

procedure TOrcamento.SetDataEmissao(const Value: string);
begin
    FDataEmissao := Value;
end;

procedure TOrcamento.SetDataEmissaoDocumento(const Value: string);
begin
    FDataEmissaoDocumento := Value;
end;

procedure TOrcamento.SetDataLimiteValidade(const Value: string);
begin
    FDataLimiteValidade := Value;
end;

procedure TOrcamento.SetDelete(const Value: string);
begin
    FDelete := Value;
end;

procedure TOrcamento.SetEndereco(const Value: string);
begin
    FEndereco := Value;
end;

procedure TOrcamento.SetEstado(const Value: string);
begin
    FEstado := Value;
end;

procedure TOrcamento.SetFilial(const Value: string);
begin
    FFilial := Value;
end;

procedure TOrcamento.SetFilial_(const Value: TFilial);
begin
    FFilial_ := Value;
end;

procedure TOrcamento.SetHora(const Value: string);
begin
    FHora := Value;
end;

procedure TOrcamento.SetLojaCliente(const Value: string);
begin
    FLojaCliente := Value;
end;

procedure TOrcamento.SetLojaTransportadora(const Value: string);
begin
    FLojaTransportadora := Value;
end;

procedure TOrcamento.SetMoeda(const Value: double);
begin
    FMoeda := Value;
end;

procedure TOrcamento.SetMunicipio(const Value: string);
begin
    FMunicipio := Value;
end;

procedure TOrcamento.SetNomeCliente(const Value: string);
begin
    FNomeCliente := Value;
end;

procedure TOrcamento.SetNomeVendedor(const Value: string);
begin
    FNomeVendedor := Value;
end;

procedure TOrcamento.SetNumero(const Value: string);
begin
    FNumero := Value;
end;

procedure TOrcamento.SetNumeroDocumento(const Value: string);
begin
    FNumeroDocumento := Value;
end;

procedure TOrcamento.SetNumeroIdentificacaoTef(const Value: string);
begin
    FNumeroIdentificacaoTef := Value;
end;

procedure TOrcamento.SetNumeroPedidoEcommerce(const Value: string);
begin
    FNumeroPedidoEcommerce := Value;
end;

procedure TOrcamento.SetObservacao1(const Value: string);
begin
    FObservacao1 := Value;
end;

procedure TOrcamento.SetObservacao2(const Value: string);
begin
    FObservacao2 := Value;
end;

procedure TOrcamento.SetOperacaoVenda(const Value: string);
begin
    FOperacaoVenda := Value;
end;

procedure TOrcamento.SetOrcamentoGeradoPeloSiatd(const Value: string);
begin
    FOrcamentoGeradoPeloSiatd := Value;
end;

procedure TOrcamento.SetOrcamentosFilhos(const Value: TLista<TOrcamento>);
begin
    FOrcamentosFilhos := Value;
end;

procedure TOrcamento.SetPercDesconto(const Value: double);
var
    valorParaDesconto: double;
    tipos: String;
begin
    if Self.TipoOperacaoDeDados <> toCarregamento then
    begin
        if Value <> 0 then
        begin
            if (Value > 99) or (Value < 0) then
                raise Erro.Create('O percentual de desconto não pode ser maior 99% ou menor 0%', MSGInformacao);

            ObterValorParaRateio(valorParaDesconto, tipos, trDesconto);
            if valorParaDesconto > 0 then
            begin
                valorParaDesconto := Tlib.ArredondarNumero((((valorParaDesconto * Value) / 100)));
                Self.ValorDesconto := valorParaDesconto;
            end;
        end
        else
        begin
            Self.FValorDesconto := 0;
            ZerarRateioValoresNosItens('ValorDesconto');
        end;
    end;

    FPercDesconto := Value;
end;

procedure TOrcamento.SetPesoBruto(const Value: double);
begin
    FPesoBruto := Value;
end;

procedure TOrcamento.SetPesoLiquido(const Value: double);
begin
    FPesoLiquido := Value;
end;

procedure TOrcamento.SetPlacaTransportadora(const Value: string);
begin
    FPlacaTransportadora := Value;
end;

procedure TOrcamento.SetRecno(const Value: integer);
begin
    FRecno := Value;
end;

procedure TOrcamento.SetRecnoDelete(const Value: integer);
begin
    FRecnoDelete := Value;
end;

procedure TOrcamento.SetSenhaAutorizador(const Value: string);
begin
    FSenhaAutorizador := Value;
end;

procedure TOrcamento.SetSerieDocumento(const Value: string);
begin
    FSerieDocumento := Value;
end;

procedure TOrcamento.SetStatusEnvioEcommerce(const Value: string);
begin
    FStatusEnvioEcommerce := Value;
end;

procedure TOrcamento.SetStatusLiberacaoEntregaFutura(const Value: string);
begin
    FStatusLiberacaoEntregaFutura := Value;
end;

procedure TOrcamento.SetStatusPedidoEcommerce(const Value: string);
begin
    FStatusPedidoEcommerce := Value;
end;

procedure TOrcamento.SetTabelaComissao(const Value: TTabelaComissao);
begin
    FTabelaComissao := Value;

    AtualizarTabelaComissaoItens;
end;

procedure TOrcamento.SetTabelaComissaoQuantidadeParcelas(const Value: integer);
begin
    FTabelaComissaoQuantidadeParcelas := Value;
end;

procedure TOrcamento.SetTipo(const Value: string);
begin
    FTipo := Value;
end;

procedure TOrcamento.SetTipoCliente(const Value: string);
begin
    FTipoCliente := Value;
end;

procedure TOrcamento.SetTipoDaVenda(const Value: string);
begin
    if Value = 'VR' then
        FTipoVenda := tvVendaRapida
    else if Value = 'VN' then
        FTipoVenda := tvVendaBalcao
    else if Value = 'VF' then
        FTipoVenda := tvVendaFutura
    else
        FTipoVenda := tvOutrosTipos;

    FTipoDaVenda := Value;
end;

procedure TOrcamento.SetTipoDesconto(const Value: string);
begin
    FTipoDesconto := Value;
end;

procedure TOrcamento.SetTipoFrete(const Value: string);
begin
    FTipoFrete := Value;
end;

procedure TOrcamento.SetTipoNotaFiscalMicrossiga(const Value: string);
begin
    FTipoNotaFiscalMicrossiga := Value;
end;

procedure TOrcamento.SetTipoOrcamento(const Value: string);
begin
    FTipoOrcamento := Value;
end;

procedure TOrcamento.SetTipoVenda(const Value: TTipoVenda);
begin
    if Value = tvVendaRapida then
        FTipoDaVenda := 'VR'
    else if Value = tvVendaFutura then
        FTipoDaVenda := 'VF'
    else
        FTipoDaVenda := 'VN';

    FTipoVenda := Value;
end;

procedure TOrcamento.SetTipoVolume(const Value: string);
begin
    FTipoVolume := Value;
end;

procedure TOrcamento.SetUFPlancaTransportadora(const Value: string);
begin
    FUFPlancaTransportadora := Value;
end;

procedure TOrcamento.SetUltimoItemAlterado(const Value: TOrcamentoItens);
begin
    FUltimoItemAlterado := Value;
end;

procedure TOrcamento.SetUsuario(const Value: string);
begin
    FUsuario := Value;
end;

procedure TOrcamento.SetUsuarioQueBloqueouOrcamento(const Value: string);
begin
    FUsuarioQueBloqueouOrcamento := Value;
end;

procedure TOrcamento.SetValorAcrescimosTotalNegociado(const Value: double);
begin
    FValorAcrescimosTotalNegociado := Value;
end;

procedure TOrcamento.SetValorBruto(const Value: double);
begin
    FValorBruto := Value;
end;

procedure TOrcamento.SetValorDesconto(const Value: double);
var
    tipos: String;
begin
    if Self.TipoOperacaoDeDados <> toCarregamento then
    begin
        if Value < 0 then
            raise Erro.Create('Valor de desconto não pode ser menor que zero.', MSGInformacao);

        if Value <> 0 then
        begin
            if ObterTotalProdutosDiferenteDeCursoSeguro(tipos) <= 0 then
                raise Erro.Create('Não é permitido dar desconto para orçamento sem produtos ou produto do tipo curso ou seguro!', MSGInformacao);
        end;

        RatearValoresNosItens(Value, 'ValorDesconto', trDesconto);
    end;

    FValorDesconto := Value;
end;

procedure TOrcamento.SetValorDescontoTotalNegociado(const Value: double);
begin
    FValorDescontoTotalNegociado := Value;
end;

procedure TOrcamento.SetValorDespesa(const Value: double);
var
    tipos: String;
begin
    if Self.TipoOperacaoDeDados <> toCarregamento then
    begin
        if Value < 0 then
            raise Erro.Create('Valor da despesa não pode ser menor que zero!', MSGInformacao);

        if Value <> 0 then
        begin
            if ObterTotalProdutosDiferenteDeCursoSeguro(tipos) <= 0 then
                raise Erro.Create('Não é permitido despesa para orçamento sem produtos ou produto do tipo curso ou seguro!', MSGInformacao);

            if ObterTotalProdutosDiferenteDeCursoSeguro(tipos) <= Value then
                raise Erro.Create('Valor de desconto é maior que o valor do orçamento.'#13 +
                    'Obs.: Produtos do tipo curso ou seguro não pode ter desconto', MSGInformacao);

            RatearValoresNosItens(Value, 'ValorDespesa', trDespesas);
        end
        else
        begin
            ZerarRateioValoresNosItens('ValorDespesa');
        end;
    end;
    FValorDespesa := Value;
end;

procedure TOrcamento.SetValorEntrada(const Value: double);
begin
    FValorEntrada := Value;
end;

procedure TOrcamento.SetValorFrete(const Value: double);
var
    tipos: String;
begin
    if Self.TipoOperacaoDeDados <> toCarregamento then
    begin
        if Value < 0 then
            raise Erro.Create('Valor do frete não pode ser menor que zero!', MSGInformacao);

        if Value <> 0 then
        begin
            if ObterTotalProdutosDiferenteDeCursoSeguro(tipos) <= 0 then
                raise Erro.Create('Não é permitido frete para orçamento sem produtos ou produto do tipo curso ou seguro!', MSGInformacao);

            if ObterTotalProdutosDiferenteDeCursoSeguro(tipos) <= Value then
                raise Erro.Create('Valor de frete é maior que o valor do orçamento.'#13 + 'Obs.: Produtos do tipo curso ou seguro não pode ter frete',
                    MSGInformacao);

            RatearValoresNosItens(Value, 'ValorFrete', trFrete);
        end
        else
        begin
            ZerarRateioValoresNosItens('ValorFrete');
        end;
    end;
    FValorFrete := Value;
end;

procedure TOrcamento.SetValorFreteTodimoTransporte(const Value: double);
begin
    FValorFreteTodimoTransporte := Value;
end;

procedure TOrcamento.SetValorIcms(const Value: double);
begin
    FValorIcms := Value;
end;

procedure TOrcamento.SetValorIpi(const Value: double);
begin
    FValorIpi := Value;
end;

procedure TOrcamento.SetValorLiquido(const Value: double);
begin
    FValorLiquido := Value;
end;

procedure TOrcamento.SetValorMercadoria(const Value: double);
begin
    FValorMercadoria := Value;
end;

procedure TOrcamento.SetValorPagoCartaoCredito(const Value: double);
begin
    FValorPagoCartaoCredito := Value;
end;

procedure TOrcamento.SetValorPagoCartaoDebito(const Value: double);
begin
    FValorPagoCartaoDebito := Value;
end;

procedure TOrcamento.SetValorPagoCheque(const Value: double);
begin
    FValorPagoCheque := Value;
end;

procedure TOrcamento.SetValorPagoConven(const Value: double);
begin
    FValorPagoConven := Value;
end;

procedure TOrcamento.SetValorPagoDinheiro(const Value: double);
begin
    FValorPagoDinheiro := Value;
end;

procedure TOrcamento.SetValorPagoDuplicata(const Value: double);
begin
    FValorPagoDuplicata := Value;
end;

procedure TOrcamento.SetValorPagoFinan(const Value: double);
begin
    FValorPagoFinan := Value;
end;

procedure TOrcamento.SetValorPromocao(const Value: double);
begin
    FValorPromocao := Value;
end;

procedure TOrcamento.SetValorSeguro(const Value: double);
var
    tipos: String;
begin
    if Self.TipoOperacaoDeDados <> toCarregamento then
    begin
        if Value < 0 then
            raise Erro.Create('Valor do seguro não pode ser menor que zero!', MSGInformacao);

        if Value <> 0 then
        begin
            if ObterTotalProdutosDiferenteDeCursoSeguro(tipos) <= 0 then
                raise Erro.Create('Não é permitido seguroe para orçamento sem produtos ou produto do tipo curso ou seguro!', MSGInformacao);

            if ObterTotalProdutosDiferenteDeCursoSeguro(tipos) <= Value then
                raise Erro.Create('Valor do seguro é maior que o valor do orçamento.'#13 +
                    'Obs.: Produtos do tipo curso ou seguro não pode ter valor de seguro', MSGInformacao);

            RatearValoresNosItens(Value, 'ValorSeguro', trSeguro);
        end
        else
        begin
            ZerarRateioValoresNosItens('ValorSeguro');
        end;
    end;

    FValorSeguro := Value;
end;

procedure TOrcamento.SetValorSubstituicao(const Value: double);
begin
    FValorSubstituicao := Value;
end;

procedure TOrcamento.SetValorTotal(const Value: double);
begin
    FValorTotal := Value;
end;

procedure TOrcamento.SetVendaComTEF(const Value: string);
begin
    FVendaComTEF := Value;
end;

procedure TOrcamento.SetVendedor(const Value: TVendedor);
begin
    FVendedor := Value;
end;

procedure TOrcamento.SetVersaoSistema(const Value: string);
begin
    FVersaoSistema := Value;
end;

procedure TOrcamento.SetVolume(const Value: double);
begin
    FVolume := Value;
end;

{$ENDREGION}

end.
